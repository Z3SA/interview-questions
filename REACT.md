# Вопросы:
1. [Что такое React?](#1-что-такое-react)
2. [Основные фичи React](#2-основные-фичи-react)
3. [Что такое JSX?](#3-что-такое-jsx)
4. [Какая разница между компонентом и элементом?](#4-какая-разница-между-компонентом-и-элементом)
5. [Как создать компонент в React?](#5-как-создать-компонент-в-react)
6. [Когда нужно использовать классовый компонент вместо функционального?](#6-когда-нужно-использовать-классовый-компонент-вместо-функционального)
7. [Что такое Pure Component?](#7-что-такое-pure-component)
8. [Что такое state в React?](#8-что-такое-state-в-react)
9. [Что такое свойства или пропсы в React компоненте?](#9-что-такое-свойства-или-пропсы-в-react-компоненте)
10. [В чём разница между state и свойствами компонента?](#10-в-чём-разница-между-state-и-свойствами-компонента)
11. [Почему не стоиит изменять состояние напрямую, через свойства?](#11-почему-не-стоиит-изменять-состояние-напрямую-через-свойства)
12. [В чём предназначение колбэк-функции в качестве второго аргумента метода `setState()`?](#12-в-чём-предназначение-колбэк-функции-в-качестве-второго-аргумента-метода-setstate)
13. [Какая разница между обработкой событий в HTML и React?](#13-какая-разница-между-обработкой-событий-в-html-и-react)
14. [Как корректно вызывать методы в классовом компоненте?](#14-как-корректно-вызывать-методы-в-классовом-компоненте)
15. [Как указать свойство, в которм оживает хендлер события или колбэк в классовом компоненте?](#15-как-указать-свойство-в-которм-оживает-хендлер-события-или-колбэк-в-классовом-компоненте)
16. [Что такое синтетические события в React?](#16-что-такое-синтетические-события-в-react)
17. [Что такое строчные условные выражения (условный рендеринг)?](#17-что-такое-строчные-условные-выражения-условный-рендеринг)
18. [Что такое свойство `key`, и для чего он?](#18-что-такое-свойство-key-и-для-чего-он)
19. [Для чего рефы?](#19-для-чего-рефы)
20. [Что делает `React.createElement()`?](#20-что-делает-reactcreateelement)
21. [Как работает рендер в React?](#21-как-работает-рендер-в-react)
22. [Когда активируется метод жизненного цикла `componentDidMount()`?](#22-когда-активируется-метод-жизненного-цикла-componentdidmount)
23. [Когда активируется метод жизненного цикла `componentWillUnmount()`?](#23-когда-активируется-метод-жизненного-цикла-componentwillunmount)
24. [Что такое подъём состояния?](#24-что-такое-подъём-состояния)
25. [Что такое `React.lazy`?](#25-что-такое-reactlazy)
26. [Что такое контекст?](#26-что-такое-контекст)
28. [Что такое перенаправление рефов?](#28-что-такое-перенаправление-рефов)
29. [Что такое `React.Fragment`?](#29-что-такое-reactfragment)
30. [Что такое HOC?](#30-что-такое-hoc)
31. [Как можно пробросить функцию в дочерний компонент?](#31-как-можно-пробросить-функцию-в-дочерний-компонент)


## 1. Что такое React?

https://github.com/sudheerj/reactjs-interview-questions#what-is-react

## 2. Основные фичи React

1. Использование Virtual DOM
2. Поддержка server-side rendering
3. Следует ненаправленному или однонаправленному направлению данных в приложении.
4. Использует переиспользуемые и комбинируемые UI компоненты для работы с view-частью.

## 3. Что такое JSX?

Это XML-подобный синтаксис в ECMAScript. При компиляции трансформируется в обычный JavaScript.

## 4. Какая разница между компонентом и элементом?

Элемент - это простой объект, описывающий то, что нужно отобразить с точки зрения узлов DOM или других компонентов. Элементы могут содержать другие элементы. После того, как элемент создан, он никогда не мутирует.

Компонент же определяется с помощью класса или функции, которые дают на выхлопе JSX для использования в `React.createElement`.

## 5. Как создать компонент в React?

- С помощью функций, вернув что-либо, что соответствует типу `ReactNode`.
- С помощью класса, наследовавшись от `React.Component`.

## 6. Когда нужно использовать классовый компонент вместо функционального?

Сейчас - почти никогда, только в случае, когда нужен полный контроль над жизненным циклом и работа с Error Boundary. Остальные основные функции классового компонента уже покрывает `useState` и `useEffect`.

## 7. Что такое Pure Component?

Pure Component - тот же компонент, только в дополнение он имеет метод жизненного цикла `shouldComponentUpdate()`, в котором сравниваются свойства и состояние, и через который можно останавливать лишние ререндеры компонента. Pure Component - выхлоп метода `React.memo()`.

## 8. Что такое state в React?

https://github.com/sudheerj/reactjs-interview-questions#what-is-state-in-react

## 9. Что такое свойства или пропсы в React компоненте?

https://github.com/sudheerj/reactjs-interview-questions#what-is-state-in-react

## 10. В чём разница между state и свойствами компонента?

Props и state - простые объекты. Они оба содержат информацию, необходимую для компонента. Но свойства приходят снаружи компонента, а состояние компонента хранится и управляется изнутри.

## 11. Почему не стоиит изменять состояние напрямую, через свойства?

Если не использовать метод `setState()` или колбэк хука `useState()` и изменять состояние напрямую, обращаясь к свойствам, React не пересоберёт компонент, из-за чего пользователь может не увидеть изменения.

## 12. В чём предназначение колбэк-функции в качестве второго аргумента метода `setState()`?

Колбэк будет вызываться, когда `setState()` будет успешно выполнен и компонент пересоберётся. Выполнение этого колбэка асинхронно.

## 13. Какая разница между обработкой событий в HTML и React?

1. В HTML события обычно пишутся полностью в lowercase, в React на camelCase.
2. В HTML можно дописать `return false`, чтобы предотвратить стандартное поведение на хендлер события, в React нужно явно вызвать `event.preventDefault()`.
3. В HTML нужно указать вызов метода, в React - ссылку на него.

## 14. Как корректно вызывать методы в классовом компоненте?

1. В конструкторе применить `bind(this)` на все методы.
2. Учитывать контекст внутри методов.
3. Использовать лямбды на методах.

## 15. Как указать свойство, в которм оживает хендлер события или колбэк в классовом компоненте?

1. Обернуть лямбдой.
2. Использовать `bind(this)`.

## 16. Что такое синтетические события в React?

`SyntheticEvent` - кроссбраузерная оболочка над нативной браузерной системой. API этого события аналогично API нативного события.

## 17. Что такое строчные условные выражения (условный рендеринг)?

https://github.com/sudheerj/reactjs-interview-questions#what-are-inline-conditional-expressions

## 18. Что такое свойство `key`, и для чего он?

`key` - специальное свойство, которое можно применить к любому элементу или компоненту в React для того, чтобы React мог понимать, какой элемент модифицировать, нужно удалить или добавить. Самое очевидное использование - получение `ReactNode` из массива.

```js
const todoItems = todos.map((todo) =>
  <li key={todo.id}>
    {todo.text}
  </li>
)
```

1. Использовать индексы в качестве ключей - не совсем надёжное решение. Лучше стоит использовать что-то иное.
2. Это свойство нужно применять на самый верхний узел.
3. Если `key` не используется с преобразованием массива в массив `ReactNode`'ов, то React оповестит об этом в консоле.

## 19. Для чего рефы?

Реф - это ссылка на элемент. Эту практику нужно по максимум избегать, только если нужен прямой доступ к DOM HTML-элементу.

## 20. Что делает `React.createElement()`?

Создаёт объект элемента из того, что было передано в функцию (JSX или объект описания элементов).

## 21. Как работает рендер в React?

1. Первый раз React получает команду на рендер командой `ReactDOM.render()`.
2. React составляет Virtual DOM и по нему строит настоящий DOM в том HTML-элементе, который указан в `render()`.
3. При получении изменений компонентов React DOM составляет новый Virtual DOM из изменившихся React-элементов или компонентов.
4. После сравнения React DOM вызывает перерисовку только тех элементов, которые действительно были изменены.

## 22. Когда активируется метод жизненного цикла `componentDidMount()`?

Когда компонент отрендерился в DOM, то есть был смонтирован.

## 23. Когда активируется метод жизненного цикла `componentWillUnmount()`?

Когда компонент принял сигнал о том, что сейчас он будет размонтирован, то есть удалён из DOM и памяти.

## 24. Что такое подъём состояния?

Хранение и управление состоянием не в границах компонента, а в границах его родителя с помощью однонаправленного потока данных (приём состояния через проп и через другой проп его отправка).

## 25. Что такое `React.lazy`?

Это способ разделения кода с выхлопом этого разделения на проде, при этом лениво загруженный компонент синтаксически ничем не будет отличаться от обычных компонентов, кроме того, что загрузку компонента нужно обработать обёрткой `Suspense`. `React.lazy` пока не умеет работать с SSR решениями. Один `Suspense` может оборачивать больше одного компонента. 

Ленивые компоненты хорошо сочетаются роутеры, React Router даже не требует `Suspense` обёртки, достаточно сразу прокинуть динамический импорт компонента.

## 26. Что такое контекст?

Контекст - решение в React, повзоляющее передавать данные без необходимости заниматься проп-дриллингом по всему дереву компонентов. Не стоит его использовать везде, иногда может спасти композиция.

### `React.createContext()`

Создаёт контекст с указанными значением по умолчанию внутри.

### `Context.Provider`

Компонент для использования в JSX, чтобы дочерниие элементы этого компонента имели доступ к этому контексту.

```js
<MyContext.Provider value={/* некоторое значение */}>
```

### `React.Component.contextType`

Поле под объект контекста, с которым должен работать классовый компонент.

### `Context.Consumer`

Это компонент, подписывающийся на изменения контекста. Позволяет взаимодействовать с контекстом в функциональном компоненте (помимо хуков).

```js
<MyContext.Consumer>
  {value => /* отрендерить что-то, используя значение контекста */}
</MyContext.Consumer>
```

### `Context.displayName`

Название контекста для React Dev Tools.

```js
const MyContext = React.createContext(/* некоторое значение */);
MyContext.displayName = 'MyDisplayName';

<MyContext.Provider> // "MyDisplayName.Provider" в DevTools
<MyContext.Consumer> // "MyDisplayName.Consumer" в DevTools
```

## 27. Что такое предохранители?

Это механизм в виде компонентов, отлавливающий JS ошибки в любом месте дочернего дерева этих компонентов, сохраняющий ошибки в журнале и выводящий запасной UI.

### Предохранители отлавливают ошибки:
- в рендере
- в методах жизненного цикла
- в конструкторах деревьев компонентов

### Предохранители не отловят ошибки:
- в обработчиках событий (там уже код выполняется императивно, поэтому можно использовать `try catch`)
- в асинхронном коде (`setTimeout`, Promise и т.д., тут тоже можно `try catch`)
- в SSR
- в самом предохранителе

Классовый компонент автоматически считается предохранителем, если он реализует один из методов жизненного цикла: `static getDerivedStateFromError(error)` или `componentDidCatch()`. Первый метод позволяет реагировать на ошибку в интерфейсе, второй - логгировать информацию об ошибке.

```js
class ErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false };
  }

  static getDerivedStateFromError(error) {
    // Обновить состояние с тем, чтобы следующий рендер показал запасной UI.
    return { hasError: true };
  }

  componentDidCatch(error, errorInfo) {
    // Можно также сохранить информацию об ошибке в соответствующую службу журнала ошибок
    logErrorToMyService(error, errorInfo);
  }

  render() {
    if (this.state.hasError) {
      // Можно отрендерить запасной UI произвольного вида
      return <h1>Что-то пошло не так.</h1>;
    }

    return this.props.children; 
  }
}

<ErrorBoundary>
  <MyWidget />
</ErrorBoundary>
```

Начиная с React 16, ошибки, не отловленные ни одним из предохранителей, будут приводить к полному размонтированию дерева компонентов.

## 28. Что такое перенаправление рефов?

Это процесс передачи рефа через один или несколько уровней компонентов.

```js
const FancyButton = React.forwardRef((props, ref) => (
  <button ref={ref} className="FancyButton">
    {props.children}
  </button>
));

// Теперь реф будет указывать непосредственно на DOM-узел button:
const ref = React.createRef();
<FancyButton ref={ref}>Click me!</FancyButton>;
```

## 29. Что такое `React.Fragment`?

Возврат нескольких элементов в компоненте невозможен, нужно возвращать именно дерево элементов и компонентов, которое будет в самом верху иметь один корневой элемент или компонент. Для того, чтобы, в случае необходимости отрендерить несколько элементов, не писать лишний `div`, придумали фрагмент:
```js
render() {
  return (
    <React.Fragment>
      <ChildA />
      <ChildB />
      <ChildC />
    </React.Fragment>
  );
}

class Columns extends React.Component {
  render() {
    return (
      <>
        <td>Привет</td>
        <td>Мир</td>
      </>
    );
  }
}
```

Чтобы рендерить меньше DOM-узлов.

## 30. Что такое HOC?

High-order-component - компонент-обёртка над другим компонентом, содержащий переиспользуемую логику, которая может пригодиться для других компонентов. В React не используется наследование, вместо него композиция. Яркий пример - `connect()` у Redux.

- Нельзя использовать HOC внутри компонентов, HOC должны быть определены снаружи.
- Для классового компонента нужно вручную копировать статические методы (можно использовать библиотеку `hoist-non-react-statics` либо использовать функциональные компоненты для бОльшей предсказуемости).
- Рефы не передаются (но можно использовать перенаправление рефов).

## 31. Как можно пробросить функцию в дочерний компонент?

1. `children` в свойствах компонента должен быть вызываемым.
2. Не забыть вызвать с нужными параметрами `children()` в компоненте А.
3. В компоненте, который, в свою очередь, использует компонент А, в его потомках вызвать функцию:
```js
// Вызывает колбэк numTimes раз для создания повторяющего компонента
function Repeat(props) {
  let items = [];
  for (let i = 0; i < props.numTimes; i++) {
    items.push(props.children(i));
  }
  return <div>{items}</div>;
}

function ListOfTenThings() {
  return (
    <Repeat numTimes={10}>
      {(index) => <div key={index}>Это элемент списка с ключом {index}</div>}
    </Repeat>
  );
}
```

## 32. Что такое портал?

Это рендер каких-то элементов, объявленных в компоненте, в совершенно другом DOM-узле.

```js
// Это два соседних контейнера в DOM
const appRoot = document.getElementById('app-root');
const modalRoot = document.getElementById('modal-root');

class Modal extends React.Component {
  constructor(props) {
    super(props);
    this.el = document.createElement('div');
  }

  componentDidMount() {
    // Элемент портала добавляется в DOM-дерево после того, как
    // потомки компонента Modal будут смонтированы, это значит,
    // что потомки будут монтироваться на неприсоединённом DOM-узле.
    // Если дочерний компонент должен быть присоединён к DOM-дереву
    // сразу при подключении, например, для замеров DOM-узла,
    // или вызова в потомке 'autoFocus', добавьте в компонент Modal
    // состояние и рендерите потомков только тогда, когда
    // компонент Modal уже вставлен в DOM-дерево.
    modalRoot.appendChild(this.el);
  }

  componentWillUnmount() {
    modalRoot.removeChild(this.el);
  }

  render() {
    return ReactDOM.createPortal(
      this.props.children,
      this.el
    );
  }
}

class Parent extends React.Component {
  constructor(props) {
    super(props);
    this.state = {clicks: 0};
    this.handleClick = this.handleClick.bind(this);
  }

  handleClick() {
    // Эта функция будет вызвана при клике на кнопку в компоненте Child,
    // обновляя состояние компонента Parent, несмотря на то,
    // что кнопка не является прямым потомком в DOM.
    this.setState(state => ({
      clicks: state.clicks + 1
    }));
  }

  render() {
    return (
      <div onClick={this.handleClick}>
        <p>Количество кликов: {this.state.clicks}</p>
        <p>
          Откройте DevTools браузера,
          чтобы убедиться, что кнопка
          не является потомком блока div
          c обработчиком onClick.
        </p>
        <Modal>
          <Child />
        </Modal>
      </div>
    );
  }
}

function Child() {
  // Событие клика на этой кнопке будет всплывать вверх к родителю,
  // так как здесь не определён атрибут 'onClick' 
  return (
    <div className="modal">
      <button>Кликните</button>
    </div>
  );
}

ReactDOM.render(<Parent />, appRoot);
```

## 33. Что такое Profiler?

Это компонент для измерения, как часто, долго и как именно ререндерятся компоненты, объявленные внутри Profiler. Этот компонент не работает в продакшн-сборке.

```js
render(
  <App>
    <Profiler id="Navigation" onRender={callback}>
      <Navigation {...props} />
    </Profiler>
    <Main {...props} />
  </App>
);
```

Основная фишка в свойстве `onRender`:
```js
function onRenderCallback(
  id, // проп "id" из дерева компонента Profiler, для которого было зафиксировано изменение
  phase, // либо "mount" (если дерево было смонтировано), либо "update" (если дерево было повторно отрендерено)
  actualDuration, // время, затраченное на рендер зафиксированного обновления
  baseDuration, // предполагаемое время рендера всего поддерева без кеширования
  startTime, // когда React начал рендерить это обновление
  commitTime, // когда React зафиксировал это обновление
  interactions // Множество «взаимодействий» для данного обновления 
) {
  // Обработка или логирование результатов...
}
```

## Источники:
[sudheerj/reactjs-interview-questions](https://github.com/sudheerj/reactjs-interview-questions)