# Вопросы:
1. [Что такое React?](#1-что-такое-react)
2. [Основные фичи React](#2-основные-фичи-react)
3. [Что такое JSX?](#3-что-такое-jsx)
4. [Какая разница между компонентом и элементом?](#4-какая-разница-между-компонентом-и-элементом)
5. [Как создать компонент в React?](#5-как-создать-компонент-в-react)
6. [Когда нужно использовать классовый компонент вместо функционального?](#6-когда-нужно-использовать-классовый-компонент-вместо-функционального)
7. [Что такое Pure Component?](#7-что-такое-pure-component)
8. [Что такое state в React?](#8-что-такое-state-в-react)
9. [Что такое свойства или пропсы в React компоненте?](#9-что-такое-свойства-или-пропсы-в-react-компоненте)
10. [В чём разница между state и свойствами компонента?](#10-в-чём-разница-между-state-и-свойствами-компонента)
11. [Почему не стоиит изменять состояние напрямую, через свойства?](#11-почему-не-стоиит-изменять-состояние-напрямую-через-свойства)
12. [В чём предназначение колбэк-функции в качестве второго аргумента метода `setState()`?](#12-в-чём-предназначение-колбэк-функции-в-качестве-второго-аргумента-метода-setstate)
13. [Какая разница между обработкой событий в HTML и React?](#13-какая-разница-между-обработкой-событий-в-html-и-react)
14. [Как корректно вызывать методы в классовом компоненте?](#14-как-корректно-вызывать-методы-в-классовом-компоненте)
15. [Как указать свойство, в которм оживает хендлер события или колбэк в классовом компоненте?](#15-как-указать-свойство-в-которм-оживает-хендлер-события-или-колбэк-в-классовом-компоненте)
16. [Что такое синтетические события в React?](#16-что-такое-синтетические-события-в-react)
17. [Что такое строчные условные выражения (условный рендеринг)?](#17-что-такое-строчные-условные-выражения-условный-рендеринг)
18. [Что такое свойство `key`, и для чего он?](#18-что-такое-свойство-key-и-для-чего-он)
19. [Для чего рефы?](#19-для-чего-рефы)
20. [Что делает `React.createElement()`?](#20-что-делает-reactcreateelement)
21. [Как работает рендер в React?](#21-как-работает-рендер-в-react)
22. [Когда активируется метод жизненного цикла `componentDidMount()`?](#22-когда-активируется-метод-жизненного-цикла-componentdidmount)
23. [Когда активируется метод жизненного цикла `componentWillUnmount()`?](#23-когда-активируется-метод-жизненного-цикла-componentwillunmount)
24. [Что такое подъём состояния?](#24-что-такое-подъём-состояния)
25. [Что такое `React.lazy`?](#25-что-такое-reactlazy)
26. [Что такое контекст?](#26-что-такое-контекст)
28. [Что такое перенаправление рефов?](#28-что-такое-перенаправление-рефов)
29. [Что такое `React.Fragment`?](#29-что-такое-reactfragment)
30. [Что такое HOC?](#30-что-такое-hoc)
31. [Как можно пробросить функцию в дочерний компонент?](#31-как-можно-пробросить-функцию-в-дочерний-компонент)
32. [Что такое портал?](#32-что-такое-портал)
33. [Что такое Profiler?](#33-что-такое-profiler)
34. [Что такое согласование в React?](#34-что-такое-согласование-в-react)
35. [Что такое рендер-пропсы?](#35-что-такое-рендер-пропсы)
36. [На что смотрит строгий режим React?](#36-на-что-смотрит-строгий-режим-react)
37. [Для чего хук `useState`?](#37-для-чего-хук-usestate)
38. [Для чего хук `useEffect`?](#38-для-чего-хук-useeffect)
39. [Для чего хук `useContext`?](#39-для-чего-хук-usecontext)
40. [Для чего хук `useReducer`?](#40-для-чего-хук-usereducer)
41. [Для чего хук `useCallback`?](#41-для-чего-хук-usecallback)
42. [Для чего хук `useMemo`?](#42-для-чего-хук-usememo)
43. [Для чего хук `useRef`?](#43-для-чего-хук-useref)
44. [Для чего хук `useImperativeHandle`?](#44-для-чего-хук-useimperativehandle)
45. [Для чего хук `useLayoutEffect`?](#45-для-чего-хук-uselayouteffect)
46. [Для чего `useDebugValue`?](#46-для-чего-usedebugvalue)
47. [Что можно сделать с помощью хуков, чего невозможно добиться, используя классы?](#47-что-можно-сделать-с-помощью-хуков-чего-невозможно-добиться-используя-классы)

## 1. Что такое React?

https://github.com/sudheerj/reactjs-interview-questions#what-is-react

## 2. Основные фичи React

1. Использование Virtual DOM
2. Поддержка server-side rendering
3. Следует ненаправленному или однонаправленному направлению данных в приложении.
4. Использует переиспользуемые и комбинируемые UI компоненты для работы с view-частью.

## 3. Что такое JSX?

Это XML-подобный синтаксис в ECMAScript. При компиляции трансформируется в обычный JavaScript.

## 4. Какая разница между компонентом и элементом?

Элемент - это простой объект, описывающий то, что нужно отобразить с точки зрения узлов DOM или других компонентов. Элементы могут содержать другие элементы. После того, как элемент создан, он никогда не мутирует.

Компонент же определяется с помощью класса или функции, которые дают на выхлопе JSX для использования в `React.createElement`.

## 5. Как создать компонент в React?

- С помощью функций, вернув что-либо, что соответствует типу `ReactNode`.
- С помощью класса, наследовавшись от `React.Component`.

## 6. Когда нужно использовать классовый компонент вместо функционального?

Сейчас - почти никогда, только в случае, когда нужен полный контроль над жизненным циклом и работа с Error Boundary. Остальные основные функции классового компонента уже покрывает `useState` и `useEffect`.

## 7. Что такое Pure Component?

Pure Component - тот же компонент, только в дополнение он имеет метод жизненного цикла `shouldComponentUpdate()`, в котором сравниваются свойства и состояние, и через который можно останавливать лишние ререндеры компонента. Pure Component - выхлоп метода `React.memo()`.

## 8. Что такое state в React?

https://github.com/sudheerj/reactjs-interview-questions#what-is-state-in-react

## 9. Что такое свойства или пропсы в React компоненте?

https://github.com/sudheerj/reactjs-interview-questions#what-is-state-in-react

## 10. В чём разница между state и свойствами компонента?

Props и state - простые объекты. Они оба содержат информацию, необходимую для компонента. Но свойства приходят снаружи компонента, а состояние компонента хранится и управляется изнутри.

## 11. Почему не стоиит изменять состояние напрямую, через свойства?

Если не использовать метод `setState()` или колбэк хука `useState()` и изменять состояние напрямую, обращаясь к свойствам, React не пересоберёт компонент, из-за чего пользователь может не увидеть изменения.

## 12. В чём предназначение колбэк-функции в качестве второго аргумента метода `setState()`?

Колбэк будет вызываться, когда `setState()` будет успешно выполнен и компонент пересоберётся. Выполнение этого колбэка асинхронно.

## 13. Какая разница между обработкой событий в HTML и React?

1. В HTML события обычно пишутся полностью в lowercase, в React на camelCase.
2. В HTML можно дописать `return false`, чтобы предотвратить стандартное поведение на хендлер события, в React нужно явно вызвать `event.preventDefault()`.
3. В HTML нужно указать вызов метода, в React - ссылку на него.

## 14. Как корректно вызывать методы в классовом компоненте?

1. В конструкторе применить `bind(this)` на все методы.
2. Учитывать контекст внутри методов.
3. Использовать лямбды на методах.

## 15. Как указать свойство, в которм оживает хендлер события или колбэк в классовом компоненте?

1. Обернуть лямбдой.
2. Использовать `bind(this)`.

## 16. Что такое синтетические события в React?

`SyntheticEvent` - кроссбраузерная оболочка над нативной браузерной системой. API этого события аналогично API нативного события.

## 17. Что такое строчные условные выражения (условный рендеринг)?

https://github.com/sudheerj/reactjs-interview-questions#what-are-inline-conditional-expressions

## 18. Что такое свойство `key`, и для чего он?

`key` - специальное свойство, которое можно применить к любому элементу или компоненту в React для того, чтобы React мог понимать, какой элемент модифицировать, нужно удалить или добавить. Самое очевидное использование - получение `ReactNode` из массива.

```js
const todoItems = todos.map((todo) =>
  <li key={todo.id}>
    {todo.text}
  </li>
)
```

1. Использовать индексы в качестве ключей - не совсем надёжное решение. Лучше стоит использовать что-то иное.
2. Это свойство нужно применять на самый верхний узел.
3. Если `key` не используется с преобразованием массива в массив `ReactNode`'ов, то React оповестит об этом в консоле.

## 19. Для чего рефы?

Реф - это ссылка на элемент. Эту практику нужно по максимум избегать, только если нужен прямой доступ к DOM HTML-элементу.

## 20. Что делает `React.createElement()`?

Создаёт объект элемента из того, что было передано в функцию (JSX или объект описания элементов).

## 21. Как работает рендер в React?

1. Первый раз React получает команду на рендер командой `ReactDOM.render()`.
2. React составляет Virtual DOM и по нему строит настоящий DOM в том HTML-элементе, который указан в `render()`.
3. При получении изменений компонентов React DOM составляет новый Virtual DOM из изменившихся React-элементов или компонентов.
4. После сравнения React DOM вызывает перерисовку только тех элементов, которые действительно были изменены.

## 22. Когда активируется метод жизненного цикла `componentDidMount()`?

Когда компонент отрендерился в DOM, то есть был смонтирован.

## 23. Когда активируется метод жизненного цикла `componentWillUnmount()`?

Когда компонент принял сигнал о том, что сейчас он будет размонтирован, то есть удалён из DOM и памяти.

## 24. Что такое подъём состояния?

Хранение и управление состоянием не в границах компонента, а в границах его родителя с помощью однонаправленного потока данных (приём состояния через проп и через другой проп его отправка).

## 25. Что такое `React.lazy`?

Это способ разделения кода с выхлопом этого разделения на проде, при этом лениво загруженный компонент синтаксически ничем не будет отличаться от обычных компонентов, кроме того, что загрузку компонента нужно обработать обёрткой `Suspense`. `React.lazy` пока не умеет работать с SSR решениями. Один `Suspense` может оборачивать больше одного компонента. 

Ленивые компоненты хорошо сочетаются роутеры, React Router даже не требует `Suspense` обёртки, достаточно сразу прокинуть динамический импорт компонента.

## 26. Что такое контекст?

Контекст - решение в React, повзоляющее передавать данные без необходимости заниматься проп-дриллингом по всему дереву компонентов. Не стоит его использовать везде, иногда может спасти композиция.

### `React.createContext()`

Создаёт контекст с указанными значением по умолчанию внутри.

### `Context.Provider`

Компонент для использования в JSX, чтобы дочерниие элементы этого компонента имели доступ к этому контексту.

```js
<MyContext.Provider value={/* некоторое значение */}>
```

### `React.Component.contextType`

Поле под объект контекста, с которым должен работать классовый компонент.

### `Context.Consumer`

Это компонент, подписывающийся на изменения контекста. Позволяет взаимодействовать с контекстом в функциональном компоненте (помимо хуков).

```js
<MyContext.Consumer>
  {value => /* отрендерить что-то, используя значение контекста */}
</MyContext.Consumer>
```

### `Context.displayName`

Название контекста для React Dev Tools.

```js
const MyContext = React.createContext(/* некоторое значение */);
MyContext.displayName = 'MyDisplayName';

<MyContext.Provider> // "MyDisplayName.Provider" в DevTools
<MyContext.Consumer> // "MyDisplayName.Consumer" в DevTools
```

## 27. Что такое предохранители?

Это механизм в виде компонентов, отлавливающий JS ошибки в любом месте дочернего дерева этих компонентов, сохраняющий ошибки в журнале и выводящий запасной UI.

### Предохранители отлавливают ошибки:
- в рендере
- в методах жизненного цикла
- в конструкторах деревьев компонентов

### Предохранители не отловят ошибки:
- в обработчиках событий (там уже код выполняется императивно, поэтому можно использовать `try catch`)
- в асинхронном коде (`setTimeout`, Promise и т.д., тут тоже можно `try catch`)
- в SSR
- в самом предохранителе

Классовый компонент автоматически считается предохранителем, если он реализует один из методов жизненного цикла: `static getDerivedStateFromError(error)` или `componentDidCatch()`. Первый метод позволяет реагировать на ошибку в интерфейсе, второй - логгировать информацию об ошибке.

```js
class ErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false };
  }

  static getDerivedStateFromError(error) {
    // Обновить состояние с тем, чтобы следующий рендер показал запасной UI.
    return { hasError: true };
  }

  componentDidCatch(error, errorInfo) {
    // Можно также сохранить информацию об ошибке в соответствующую службу журнала ошибок
    logErrorToMyService(error, errorInfo);
  }

  render() {
    if (this.state.hasError) {
      // Можно отрендерить запасной UI произвольного вида
      return <h1>Что-то пошло не так.</h1>;
    }

    return this.props.children; 
  }
}

<ErrorBoundary>
  <MyWidget />
</ErrorBoundary>
```

Начиная с React 16, ошибки, не отловленные ни одним из предохранителей, будут приводить к полному размонтированию дерева компонентов.

## 28. Что такое перенаправление рефов?

Это процесс передачи рефа через один или несколько уровней компонентов.

```js
const FancyButton = React.forwardRef((props, ref) => (
  <button ref={ref} className="FancyButton">
    {props.children}
  </button>
));

// Теперь реф будет указывать непосредственно на DOM-узел button:
const ref = React.createRef();
<FancyButton ref={ref}>Click me!</FancyButton>;
```

## 29. Что такое `React.Fragment`?

Возврат нескольких элементов в компоненте невозможен, нужно возвращать именно дерево элементов и компонентов, которое будет в самом верху иметь один корневой элемент или компонент. Для того, чтобы, в случае необходимости отрендерить несколько элементов, не писать лишний `div`, придумали фрагмент:
```js
render() {
  return (
    <React.Fragment>
      <ChildA />
      <ChildB />
      <ChildC />
    </React.Fragment>
  );
}

class Columns extends React.Component {
  render() {
    return (
      <>
        <td>Привет</td>
        <td>Мир</td>
      </>
    );
  }
}
```

Чтобы рендерить меньше DOM-узлов.

## 30. Что такое HOC?

High-order-component - компонент-обёртка над другим компонентом, содержащий переиспользуемую логику, которая может пригодиться для других компонентов. В React не используется наследование, вместо него композиция. Яркий пример - `connect()` у Redux.

- Нельзя использовать HOC внутри компонентов, HOC должны быть определены снаружи.
- Для классового компонента нужно вручную копировать статические методы (можно использовать библиотеку `hoist-non-react-statics` либо использовать функциональные компоненты для бОльшей предсказуемости).
- Рефы не передаются (но можно использовать перенаправление рефов).

## 31. Как можно пробросить функцию в дочерний компонент?

1. `children` в свойствах компонента должен быть вызываемым.
2. Не забыть вызвать с нужными параметрами `children()` в компоненте А.
3. В компоненте, который, в свою очередь, использует компонент А, в его потомках вызвать функцию:
```js
// Вызывает колбэк numTimes раз для создания повторяющего компонента
function Repeat(props) {
  let items = [];
  for (let i = 0; i < props.numTimes; i++) {
    items.push(props.children(i));
  }
  return <div>{items}</div>;
}

function ListOfTenThings() {
  return (
    <Repeat numTimes={10}>
      {(index) => <div key={index}>Это элемент списка с ключом {index}</div>}
    </Repeat>
  );
}
```

## 32. Что такое портал?

Это рендер каких-то элементов, объявленных в компоненте, в совершенно другом DOM-узле.

```js
// Это два соседних контейнера в DOM
const appRoot = document.getElementById('app-root');
const modalRoot = document.getElementById('modal-root');

class Modal extends React.Component {
  constructor(props) {
    super(props);
    this.el = document.createElement('div');
  }

  componentDidMount() {
    // Элемент портала добавляется в DOM-дерево после того, как
    // потомки компонента Modal будут смонтированы, это значит,
    // что потомки будут монтироваться на неприсоединённом DOM-узле.
    // Если дочерний компонент должен быть присоединён к DOM-дереву
    // сразу при подключении, например, для замеров DOM-узла,
    // или вызова в потомке 'autoFocus', добавьте в компонент Modal
    // состояние и рендерите потомков только тогда, когда
    // компонент Modal уже вставлен в DOM-дерево.
    modalRoot.appendChild(this.el);
  }

  componentWillUnmount() {
    modalRoot.removeChild(this.el);
  }

  render() {
    return ReactDOM.createPortal(
      this.props.children,
      this.el
    );
  }
}

class Parent extends React.Component {
  constructor(props) {
    super(props);
    this.state = {clicks: 0};
    this.handleClick = this.handleClick.bind(this);
  }

  handleClick() {
    // Эта функция будет вызвана при клике на кнопку в компоненте Child,
    // обновляя состояние компонента Parent, несмотря на то,
    // что кнопка не является прямым потомком в DOM.
    this.setState(state => ({
      clicks: state.clicks + 1
    }));
  }

  render() {
    return (
      <div onClick={this.handleClick}>
        <p>Количество кликов: {this.state.clicks}</p>
        <p>
          Откройте DevTools браузера,
          чтобы убедиться, что кнопка
          не является потомком блока div
          c обработчиком onClick.
        </p>
        <Modal>
          <Child />
        </Modal>
      </div>
    );
  }
}

function Child() {
  // Событие клика на этой кнопке будет всплывать вверх к родителю,
  // так как здесь не определён атрибут 'onClick' 
  return (
    <div className="modal">
      <button>Кликните</button>
    </div>
  );
}

ReactDOM.render(<Parent />, appRoot);
```

## 33. Что такое Profiler?

Это компонент для измерения, как часто, долго и как именно ререндерятся компоненты, объявленные внутри Profiler. Этот компонент не работает в продакшн-сборке.

```js
render(
  <App>
    <Profiler id="Navigation" onRender={callback}>
      <Navigation {...props} />
    </Profiler>
    <Main {...props} />
  </App>
);
```

Основная фишка в свойстве `onRender`:
```js
function onRenderCallback(
  id, // проп "id" из дерева компонента Profiler, для которого было зафиксировано изменение
  phase, // либо "mount" (если дерево было смонтировано), либо "update" (если дерево было повторно отрендерено)
  actualDuration, // время, затраченное на рендер зафиксированного обновления
  baseDuration, // предполагаемое время рендера всего поддерева без кеширования
  startTime, // когда React начал рендерить это обновление
  commitTime, // когда React зафиксировал это обновление
  interactions // Множество «взаимодействий» для данного обновления 
) {
  // Обработка или логирование результатов...
}
```

## 34. Что такое согласование в React?

Это принцип, по которому React DOM анализирует, как именно изменить DOM после получения нового состояния Virtual DOM с максимальной эффективностью.

Как кратко происходит рендер элементов с помощью React:
1. При первом рендере React создаёт дерево элементов.
2. При обновлении состояния или пропсов React вернёт новое дерево элементов для того же Virtual DOM.
3. Так как полностью перерисовывать настоящий DOM по новому дереву Virtual DOM слишком дорого, React будет рендерить только те элементы, которые изменились.
4. Но так как Virtual DOM - это структура дерева, даже передовые алгоритмы имеют сложность порядка O(n^3) для сравнения деревьев, что значит при наличии 1000 элементов будет произведено 1 000 000 000 операций.
5. Для избежания такого огромног количества операций React учитывает два возможных сценария:
  1. Два элемента с разными типами произведут разные деревья.
  2. Разработчик может указать, какие дочерние элементы могут оставаться стабильными между разными рендерами с помощью свойства `key`.
  3. На практике эти два предположения покрывают очень много изменений.
6. В итоге React сравнивает корневые элементы.
  1. Если корневые элементы различаются:
    1. React уничтожает старое дерево и генерирует новое, что позволяет избежать от одного до огромной кучи сравнений.
    2. При уничтожении дерева старые DOM-узлы удаляются.
    3. Экземпляры компонентов получают `componentWillUnmount()`.
    4. Монтируются новые DOM-узлы по новому Virtual DOM.
    5. Экземпляры компонента нового дерева получают `UNSAFE_componentWillMount()` и `componentDidMount()`.
  2. Если корневые элементы имеют один тип:
    1. React проверяет различие атрибутов и исправляет их, если имеется (ставятся новые, удаляются старые).
    2. React идёт дальше по дочерним элементам рекурсивно.
  3. Если компонент не изменил свою позицию в дереве:
    1. React обновляет свойства базового экземпляра компонента для соответствия новому элементу и вызывает `UNSAFE_componentWillRecieveProps()`, `UNSAFE_componentWillUpdate()` и `componentDidUpdate()`.
    2. Дальше происходит рекурсивный обход детей.
7. При рекурсивном обходе детей React проходит по обоими деревьям и создаёт мутации в DOM при отличии.
8. При вставке элементов или изменении их порядка стоит указывать `key`, чтобы React мог по ним ориентироваться и, в случае обнаружения схожих по ключу элементов в разных деревьях и на разных местах, нужно было сравнивать их как одинаковые элементы, а не разные.

## 35. Что такое рендер-пропсы?

Это возможность прокидывать компоненты помимо прямых потомков в компонент.

## 36. На что смотрит строгий режим React?

1. Обнаружение небезопасных методов жизненного цикла (с пометкой `UNSAFE`)
2. Предупреждение при использовании строковых рефов
3. Предупреждение об использовании устаревшего `findDOMNode`
4. Методы жизненного цикла компонента вызываются дважды (для исключения сложных проблем, связанных с использованием этих методов)
5. Обнаружение устаревшего API контекста

## 37. Для чего хук `useState`?

Возвращает значение с состоянием и функцию для его обновления.

Во время первоначального рендеринга возвращаемое состояние (state) совпадает со значением, переданным в качестве первого аргумента (initialState).

Функция `setState` используется для обновления состояния. Она принимает новое значение состояния и ставит в очередь повторный рендер компонента.

Во время последующих повторных рендеров первое значение, возвращаемое useState, всегда будет самым последним состоянием после применения обновлений.

## 38. Для чего хук `useEffect`?

Принимает функцию, которая содержит императивный код, возможно, с эффектами.

Мутации, подписки, таймеры, логирование и другие побочные эффекты не допускаются внутри основного тела функционального компонента (называемого этапом рендеринга React). Это приведёт к запутанным ошибкам и несоответствиям в пользовательском интерфейсе.

Вместо этого используйте `useEffect`. Функция, переданная в useEffect, будет запущена после того, как рендер будет зафиксирован на экране. Думайте об эффектах как о лазейке из чисто функционального мира React в мир императивов.

По умолчанию эффекты запускаются после каждого завершённого рендеринга, но вы можете решить запускать их только при изменении определённых значений.

### Очистка эффекта

Часто эффекты создают ресурсы, которые необходимо очистить (или сбросить) перед тем, как компонент покидает экран, например подписку или идентификатор таймера. Чтобы сделать это, функция переданная в useEffect, может вернуть функцию очистки. Например, чтобы создать подписку.

Функция очистки запускается до удаления компонента из пользовательского интерфейса, чтобы предотвратить утечки памяти. Кроме того, если компонент рендерится несколько раз (как обычно происходит), предыдущий эффект очищается перед выполнением следующего эффекта. В нашем примере это означает, что новая подписка создаётся при каждом обновлении. Чтобы избежать воздействия на каждое обновление, обратитесь к следующему разделу.

### Порядок срабатывания эффектов

В отличие от `componentDidMount` и `componentDidUpdate`, функция, переданная в `useEffect`, запускается во время отложенного события после разметки и отрисовки. Это делает хук подходящим для многих распространённых побочных эффектов, таких как настройка подписок и обработчиков событий, потому что большинство типов работы не должны блокировать обновление экрана браузером.

Однако не все эффекты могут быть отложены. Например, изменение DOM, которое видно пользователю, должно запускаться синхронно до следующей отрисовки, чтобы пользователь не замечал визуального несоответствия. (Различие концептуально схоже с пассивным и активным слушателями событий.) Для этих типов эффектов React предоставляет один дополнительный хук, называемый `useLayoutEffect`. Он имеет ту же сигнатуру, что и `useEffect`, и отличается только в его запуске.

Хотя `useEffect` откладывается до тех пор, пока браузер не выполнит отрисовку, он гарантированно срабатывает перед любыми новыми рендерами. React всегда полностью применяет эффекты предыдущего рендера перед началом нового обновления.

### Условное срабатывание эффекта

По умолчанию эффекты запускаются после каждого завершённого рендера. Таким образом, эффект всегда пересоздаётся, если значение какой-то из зависимости изменилось.

Однако в некоторых случаях это может быть излишним, например, в примере подписки из предыдущего раздела. Нам не нужно создавать новую подписку на каждое обновление, а только если изменился проп source.

Чтобы реализовать это, передайте второй аргумент в useEffect, который является массивом значений, от которых зависит эффект.

Массив зависимостей не передаётся в качестве аргументов функции эффекта. Тем не менее, в теории вот что происходит: каждое значение, на которое ссылается функция эффекта, должно также появиться в массиве зависимостей. В будущем достаточно продвинутый компилятор сможет создать этот массив автоматически.

## 39. Для чего хук `useContext`?

Принимает объект контекста (значение, возвращённое из `React.createContext`) и возвращает текущее значение контекста для этого контекста. Текущее значение контекста определяется пропом `value` ближайшего `<MyContext.Provider>` над вызывающим компонентом в дереве.

Когда ближайший `<MyContext.Provider>` над компонентом обновляется, этот хук вызовет повторный рендер с последним значением контекста, переданным этому провайдеру `MyContext`. Даже если родительский компонент использует `React.memo` или реализует `shouldComponentUpdate`, то повторный рендер будет выполняться, начиная c компонента, использующего `useContext`.

## 40. Для чего хук `useReducer`?

Альтернатива для `useState`. Принимает редюсер типа `(state, action) => newState` и возвращает текущее состояние в паре с методом `dispatch`. (Если вы знакомы с Redux, вы уже знаете, как это работает.)

Хук `useReducer` обычно предпочтительнее `useState`, когда у вас сложная логика состояния, которая включает в себя несколько значений, или когда следующее состояние зависит от предыдущего. `useReducer` также позволяет оптимизировать производительность компонентов, которые запускают глубокие обновления, поскольку вы можете передавать `dispatch` вместо колбэков.

### Указание начального состояния

Существует два разных способа инициализации состояния useReducer. Вы можете выбрать любой из них в зависимости от ситуации. Самый простой способ — передать начальное состояние в качестве второго аргумента.

### Ленивая инициализация

Вы также можете создать начальное состояние лениво. Для этого вы можете передать функцию `init` в качестве третьего аргумента. Начальное состояние будет установлено равным результату вызова `init(initialArg)`.

Это позволяет извлечь логику для расчёта начального состояния за пределы редюсера.

### Досрочное прекращение `dispatch`

Если вы вернёте то же значение из редюсера хука, что и текущее состояние, React выйдет без перерисовки дочерних элементов или запуска эффектов. (React использует алгоритм сравнения `Object.is`.)

Обратите внимание, что для React всё ещё может быть необходим повторный рендер этого компонента. Это не должно быть проблемой, потому что React не будет сильно «углубляться» в дерево. Если вы делаете дорогостоящие вычисления во время рендеринга, вы можете оптимизировать их с помощью `useMemo`.

## 41. Для чего хук `useCallback`?

Возвращает мемоизированный колбэк.

Передайте встроенный колбэк и массив зависимостей. Хук `useCallback` вернёт мемоизированную версию колбэка, который изменяется только, если изменяются значения одной из зависимостей. Это полезно при передаче колбэков оптимизированным дочерним компонентам, которые полагаются на равенство ссылок для предотвращения ненужных рендеров (например, `shouldComponentUpdate`).

`useCallback(fn, deps)` — это эквивалент `useMemo(() => fn, deps)`.

## 42. Для чего хук `useMemo`?

Возвращает мемоизированное значение.

Передайте «создающую» функцию и массив зависимостей. `useMemo` будет повторно вычислять мемоизированное значение только тогда, когда значение какой-либо из зависимостей изменилось. Эта оптимизация помогает избежать дорогостоящих вычислений при каждом рендере.

Помните, что функция, переданная `useMemo`, запускается во время рендеринга. Не делайте там ничего, что вы обычно не делаете во время рендеринга. Например, побочные эффекты принадлежат `useEffect`, а не `useMemo`.

Если массив не был передан, новое значение будет вычисляться при каждом рендере.

Вы можете использовать `useMemo` как оптимизацию производительности, а не как семантическую гарантию. В будущем React может решить «забыть» некоторые ранее мемоизированные значения и пересчитать их при следующем рендере, например, чтобы освободить память для компонентов вне области видимости экрана. Напишите свой код, чтобы он по-прежнему работал без `useMemo`, а затем добавьте его для оптимизации производительности.

## 43. Для чего хук `useRef`?

`useRef` возвращает изменяемый ref-объект, свойство .current которого инициализируется переданным аргументом (`initialValue`). Возвращённый объект будет сохраняться в течение всего времени жизни компонента.

Обычный случай использования — это доступ к потомку в императивном стиле.

По сути, `useRef` похож на «коробку», которая может содержать изменяемое значение в своём свойстве `.current`.

Возможно, вы знакомы с рефами в основном как со способом получить доступ к DOM. Если вы передадите React объект рефа с помощью подобного выражения `<div ref={myRef}/>`, React установит собственное свойство `.current` на соответствующий DOM-узел при каждом его изменении.

Но хук `useRef()` полезен не только установкой атрибута с рефом. Он удобен для сохранения любого мутируемого значения, по аналогии с тем, как вы используете поля экземпляра в классах.

Это возможно, поскольку `useRef()` создаёт обычный JavaScript-объект. Единственная разница между useRef() и просто созданием самого объекта {current: ...} — это то, что хук useRef даст один и тот же объект с рефом при каждом рендере.

Имейте в виду, что useRef не уведомляет вас, когда изменяется его содержимое. Мутирование свойства .current не вызывает повторный рендер. Если вы хотите запустить некоторый код, когда React присоединяет или отсоединяет реф к узлу DOM, вы можете использовать колбэк-реф вместо этого.

## 44. Для чего хук `useImperativeHandle`?

Модификация реф-экземпляра, предоставляемого родительским компонентом. Какая-то жесть, стоит разбираться на примерах.

## 45. Для чего хук `useLayoutEffect`?

Сигнатура идентична `useEffect`, но этот хук запускается синхронно после всех изменений DOM. Используйте его для чтения макета из DOM и синхронного повторного рендеринга. Обновления, запланированные внутри `useLayoutEffect`, будут полностью применены синхронно перед тем, как браузер получит шанс осуществить отрисовку.

Предпочитайте стандартный `useEffect`, когда это возможно, чтобы избежать блокировки визуальных обновлений.

## 46. Для чего `useDebugValue`?

`useDebugValue` может использоваться для отображения метки для пользовательских хуков в React DevTools.

## 47. Что можно сделать с помощью хуков, чего невозможно добиться, используя классы?

Хуки дают новый мощный способ повторного использования кода в компонентах.

## 48. Дают ли хуки все возможности классов?

Пока не существует хуков, реализующих методы жизненного цикла `getSnapshotBeforeUpdate`, `getDerivedStateFromError` и `componentDidCatch`.

## Источники:
[sudheerj/reactjs-interview-questions](https://github.com/sudheerj/reactjs-interview-questions)
[React RU Docs](https://ru.reactjs.org/)