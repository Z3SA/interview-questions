# Вопросы:
1. [Объясните делегирование событий](#1-объясните-делегирование-событий)
2. [Объясните, как работает this](#2-объясните-как-работает-this)
3. [Расскажите, как работает прототипное наследование](#3-расскажите-как-работает-прототипное-наследование)
4. [В чём разница между `__proto__`, `prototype` и оператором `new`?](#4-в-чём-разница-между-proto-prototype-и-оператором-new)
5. [Что вы думаете о AMD против CommonJS?](#5-что-вы-думаете-о-amd-против-commonjs)
6. [Объясните, почему это не является IIFE: function foo(){ }();. Что необходимо изменить, чтобы это стало IIFE?](#6-объясните-почему-это-не-является-iife-function-foo--что-необходимо-изменить-чтобы-это-стало-iife)
7. [В чем различие между переменными, значение которых: `null`, `undefined` и не объявлено? Как бы вы проверили их на каждое из этих значений?](#7-в-чем-различие-между-переменными-значение-которых-null-undefined-и-не-объявлено-как-бы-вы-проверили-их-на-каждое-из-этих-значений)
8. [Что такое замыкание и как/для чего его используют?](#8-что-такое-замыкание-и-какдля-чего-его-используют)
9. [Можете ли вы описать основное различие между циклом .forEach и циклом .map()? И в каких случаях каждый из них используется?](#9-можете-ли-вы-описать-основное-различие-между-циклом-foreach-и-циклом-map-и-в-каких-случаях-каждый-из-них-используется)
10. [В каких случаях обычно используются анонимные функции?](#10-в-каких-случаях-обычно-используются-анонимные-функции)
11. [В чем разница между host-объектами и нативными объектами?](#11-в-чем-разница-между-host-объектами-и-нативными-объектами)
12. [В чем разница между: `function Person(){}`, `var person = Person()`, и `var person = new Person()`?](#12-в-чем-разница-между-function-person-var-person--person-и-var-person--new-person)
13. [В чем разница между `.call` и `.apply`?](#13-в-чем-разница-между-call-и-apply)
14. [Что делает и для чего нужна функция `.bind`?](#14-что-делает-и-для-чего-нужна-функция-bind)
15. [В каких случаях используется `document.write()`?](#15-в-каких-случаях-используется-documentwrite)
16. [В чём разница между feature detection (определение возможностей браузера), ferature inference (предположение возможностей) и анализом строки user-agent?](#16-в-чём-разница-между-feature-detection-определение-возможностей-браузера-ferature-inference-предположение-возможностей-и-анализом-строки-user-agent)
17. [Расскажите об AJAX](#17-расскажите-об-ajax)
18. [Какие преимущества и недостатки в использовании Ajax?](#18-какие-преимущества-и-недостатки-в-использовании-ajax)
19. [Объясните, как работает JSONP (и почему это не совсем AJAX)](#19-объясните-как-работает-jsonp-и-почему-это-не-совсем-ajax)
20. [Вы когда-нибудь использовали шаблонизацию на JavaScript? Если да, то какие библиотеки вы использовали?](#20-вы-когда-нибудь-использовали-шаблонизацию-на-javascript-если-да-то-какие-библиотеки-вы-использовали)
21. [Расскажите, что такое поднятие (hoisting)](#21-расскажите-что-такое-поднятие-hoisting)
22. [Объясните, что такое всплытие событий (event bubbling)](#22-объясните-что-такое-всплытие-событий-event-bubbling)
23. [В чем разница между "атрибутом" (attribute) и "свойством" (property)?](#23-в-чем-разница-между-"атрибутом"-attribute-и-"свойством"-property)
24. [Почему не следует расширять нативные JavaScript-объекты?](#24-почему-не-следует-расширять-нативные-javascript-объекты)
25. [В чем разница между событием `load` и событием `DOMContentLoaded`?](#25-в-чем-разница-между-событием-load-и-событием-domcontentloaded)
26. [В чём разница между `==` и `===`?](#26-в-чём-разница-между--и)
27. [Объясните same-origin policy в контексте JavaScript](#27-объясните-same-origin-policy-в-контексте-javascript)
28. [Сделайте так, чтобы код `duplicate([1, 2, 3, 4, 5]); // [1,2,3,4,5,1,2,3,4,5]` работал](#28)
29. [Почему тернарный оператор так называется?](#29-почему-тернарный-оператор-так-называется)
30. [Что делает строчка `"use strict";`? Какие достоинства и недостатки от ее использования?](#30-что-делает-строчка-"use-strict"-какие-достоинства-и-недостатки-от-ее-использования)
31. [Напишите цикл, который перебирает числа до 100, возвращая "fizz" на числа кратные 3, "buzz" на числа кратные 5 и "fizzbuzz" на числа кратные 3 и 5.](#31-напишите-цикл-который-перебирает-числа-до-100-возвращая-"fizz"-на-числа-кратные-3-"buzz"-на-числа-кратные-5-и-"fizzbuzz"-на-числа-кратные-3-и-5)
32. [Почему считается хорошим тоном оставить глобальную область видимости (global scope) в нетронутом состоянии?](#32-почему-считается-хорошим-тоном-оставить-глобальную-область-видимости-global-scope-в-нетронутом-состоянии)
33. [Для чего используют событие `load`? Есть ли у этого события недостатки? Знаете ли вы какие-либо альтернативы, и в каких случаях бы стали их использовать?](#33-для-чего-используют-событие-load-есть-ли-у-этого-события-недостатки-знаете-ли-вы-какие-либо-альтернативы-и-в-каких-случаях-бы-стали-их-использовать)
34. [Как сделать одностраничное приложение SEO-оптимизированным.](#34-как-сделать-одностраничное-приложение-seo-оптимизированным)
35. [Насколько вы опытны в работе с промисами (promises) и/или их полифилами?](#35-насколько-вы-опытны-в-работе-с-промисами-promises-иили-их-полифилами)
36. [Какие преимущества и недостатки при использовании промисов вместо колбэков (callbacks)?](#36-какие-преимущества-и-недостатки-при-использовании-промисов-вместо-колбэков-callbacks)
37. [Каковы преимущества и недостатки написания JavaScript-кода на языке, который компилируется в JavaScript?](#37-каковы-преимущества-и-недостатки-написания-javascript-кода-на-языке-который-компилируется-в-javascript)
38. [Какие инструменты отладки существуют в JS?](#38-какие-инструменты-отладки-существуют-в-js)
39. [Какие языковые конструкции можно использовать для итерации по свой свойствам объекта и элеметам массива?](#39-какие-языковые-конструкции-можно-использовать-для-итерации-по-свой-свойствам-объекта-и-элеметам-массива)
40. [Объясните разницу между изменяемыми (mutable) и неизменяемыми (immutable) объектами](#40-объясните-разницу-между-изменяемыми-mutable-и-неизменяемыми-immutable-объектами)
41. [Объясните разницу между синхронными и асинхронными функциями](#41-объясните-разницу-между-синхронными-и-асинхронными-функциями)
42. [Что такое event loop?](#42-что-такое-event-loop)
43. [Объясните разницу между `function foo() {}` и `var foo = function() {}` при объявлении в одинаковых условиях.](#43-объясните-разницу-между-function-foo--и-var-foo--function--при-объявлении-в-одинаковых-условиях)
44. [В чём разница между `var`, `let` и `const`?](#44-в-чём-разница-между-var-let-и-const)
45. [В чем разница между классом в ES6 и функцией-конструктором в ES5?](#45-в-чем-разница-между-классом-в-es6-и-функцией-конструктором-в-es5)
46. [Можете ли вы привести пример использования стрелочных функции =>? Чем они отличаются от других функций?](#46-можете-ли-вы-привести-пример-использования-стрелочных-функции--чем-они-отличаются-от-других-функций)
47. [В чем преимущество использования стрелочных функций для метода в конструкторе?](#47-в-чем-преимущество-использования-стрелочных-функций-для-метода-в-конструкторе)
48. [Что такое функции высшего порядка](#48-что-такое-функции-высшего-порядка)
49. [Можете ли вы привести пример деструктуризации объекта или массива?](#49-можете-ли-вы-привести-пример-деструктуризации-объекта-или-массива)
50. [Шаблонные строки в ES6 намного упрощают создание строк, можете ли вы привести пример их использования?](#50-шаблонные-строки-в-es6-намного-упрощают-создание-строк-можете-ли-вы-привести-пример-их-использования)
51. [Можете ли вы привести пример каррированной функции (curry function) и в чем их преимущество?](#51-можете-ли-вы-привести-пример-каррированной-функции-curry-function-и-в-чем-их-преимущество)
52. [В чем преимущества использования spread оператора и чем он отличается от rest оператора?](#52-в-чем-преимущества-использования-spread-оператора-и-чем-он-отличается-от-rest-оператора)
53. [Каким образом можно обмениваться кодом между файлами?](#53-каким-образом-можно-обмениваться-кодом-между-файлами)
54. [Для чего используются статические члены класса?](#54-для-чего-используются-статические-члены-класса)
55. [Какие есть способы создания объекта?](#55-какие-есть-способы-создания-объекта)
56. [Для чего метод `slice()` у массивов?](#56-для-чего-метод-slice-у-массивов)
57. [Для чего метод `splice()` у массивов?](#57-для-чего-метод-splice-у-массивов)
58. [В чём разница между `slice()` и `splice()`?](#58-в-чём-разница-между-slice-и-splice)
59. [В чём схожесть и различие `Object` и `Map`?](#59-в-чём-схожесть-и-различие-object-и-map)


## 1. Объясните делегирование событий

Делегирование событий - это приём, заключающийся в добавлении обработчиков событий к родительскому элементу, а не к дочерним элементам. Обработчик будет срабатывать всякий раз, когда событие будет запущено на дочерних элементах благодаря всплытию событий в DOM. Преимущества этого приёма:
- Экономит объем используемой памяти, т.к. для родительского элемента требуется только один обработчик.
- Не нужно привязывать или убирать обработчики при добавлении и удалении элементов.

[Источник 1](https://davidwalsh.name/event-delegate), [Источник 2](https://stackoverflow.com/questions/1687296/what-is-dom-event-delegation)

## 2. Объясните, как работает this

Нельзя в двух словах объяснить, как работает `this` - это одно из самых запутанных понятий в JS. Значение `this` зависит от того, как вызывается функция.

Есть следующие правила определения, чем является `this`:
- Если используется ключевое слово `new` при вызове функции, `this` внутри функции будет новым объектом.
- Если для вызова или создания функции используются методы `bind`, `call` или `apply`, то `this` внутри функции - это объект, который передали в качестве аргумента.
- Если функция вызывается как метод (`obj.method()`), то `this` - это объект, к которому принадлежит функция (метод).
- Если функция вызывается без контекста, то есть без условий, описанных выше, то в браузере `this` - это объект `window`. В строгом режиме (`use strict`) `this` будет `undefined` вместо глобального объекта.
- Если применяется несколько из вышеперечисленных правил, то правило, которое выше, имеет приоритет.
- Если функция является стрелочной функцией, то она игнорирует все вышеописанные правила и получает значения `this` из лексического окружения во время её создания.

[Источник 1](https://codeburst.io/the-simple-rules-to-this-in-javascript-35d97f31bde3), [Источник 2](https://stackoverflow.com/a/3127440/1751946)

## 3. Расскажите, как работает прототипное наследование

Все объекты в JavaScript имеют свойство `__proto__`, которое является ссылкой на другой объект. Когда происходит обращение к свойству объекта, и если свойство не найдено в этом объекте, то механизм JavaScript просматривает прототип объекта, затем прототип прототипа и т.д. До тех пор, пока не найдет определенное свойство на одном из прототипов или до тех пор, пока он не достигнет конца цепочки прототипов. Такое поведение имитирует классическое наследование, но на самом деле это скорее делегирование, чем наследование.

## 4. В чём разница между `__proto__`, `prototype` и оператором `new`?

#### Свойство `__proto__`

Абсолютно любой объект в JavaScript имеет свойство `__proto__`. Это скрытое системное свойство, и не во всех реализациях языка оно доступно пользователю. При обращении к любому свойству объекта, оно в первую очередь ищется в самом объекте. Но если его там нет, поиск происходит в свойстве `__proto__`. Если его нет и там, оно ищется дальше по цепочке. Эта цепочка называется цепочкой прототипов (prototype chain). Последнее звено `__proto__` всегда равно `null`.

#### Свойство `prototype`

Это обычное свойство, ничем не отличающиеся от любых других свойств. За исключением двух особенностей:
1. Функции в JavaScript имеют свойство `prototype`. Оно по умолчанию является объектом с единственным свойством constructor, которое ссылается на саму функцию.
2. Свойство `prototype` используется при создании новых объектов оператором `new`.

#### Оператор `new`

Оператор делает следующее:
1. Создаёт пустой объект.
```js
var instance = {};
```

2. Устанавливает `__proto__` этому объекту ссылкой на `prototype` функции-класса:
```js
instance.__proto__ = FnClass.prototype;
```

3. Применяет функцию-класс к нашему новосозданному объекту, т.е. исполняет функцию `FnClass`, передавая ей `instance` в качестве `this` и аргументы в виде массива `arguments`:
```js
constructorReturns = FnClass.apply(instance, arguments);
```

4. Возвращает экземпляр функции-класса, но если `FnClass` нам вернул обьект, тогда его:
```js
return constructorReturns instanceof Object ? constructorReturns : instance;
```

Функцией-классом я называю функцию, к которой впоследствии ожидается применение оператора new. Такие функции принято именовать с заглавной буквы.

## 5. Что вы думаете о AMD против CommonJS?

Оба являются способами реализации системы модулей до появления ES2015 и его нативной системы модулей. CommonJS является синхронным, а AMD (Async Module Definition) - асинхронным. CommonJS разработан с учётом разработки на стороне сервера, в то время как AMD с поддержкой асинхронной загрузки модулей больше предназначен для браузеров.

AMD можно считать ненужным из-за асинхронности, которой никто может и не воспользоваться. При этом CommonJS ближе к стилю модулей Node, что даёт меньше путаницы при переключении между клиентской и серверной разработкой.

[Источник 1](https://auth0.com/blog/javascript-module-systems-showdown/), [Источник 2](https://stackoverflow.com/questions/16521471/relation-between-commonjs-amd-and-requirejs)

## 6. Объясните, почему это не является IIFE: function foo(){ }();. Что необходимо изменить, чтобы это стало IIFE?

IIFE расшифровывается как Immediately Invoked Function Expression - немедленно вызываемое функциональное выражение. Синтаксический анализатор JavaScript читает `function foo(){ } ();` как `function foo(){ }` и `();`, где первое выражение - это объявление функции, а второе (пара скобок) - попытка вызова функции, но так как имя не указано, он выдает ошибку `Uncaught SyntaxError: Unexpected token`.

Вот два способа исправить это, которые заключаются добавление дополнительных скобок: `(function foo(){ })()` и `(function foo(){ }())`. Выражения, начинающиеся с `function`, считаются объявлениями функций. Оборачивая эту функцию внутри `()`, она становится функциональным выражением, которое затем может быть выполнено с последующим `()`. Подобные функции не отображаются в глобальной области видимости, и вы можете даже не указывать им имя, если вы не будете на них ссылаться.

Вы также можете использовать оператор `void` - `void function foo(){ }()`. К сожалению, с таким подходом есть одна проблема. Выполнение данного выражения всегда возвращает `undefined`, поэтому, если ваше IIFE возвращает что-либо, вы не можете его использовать.

## 7. В чем различие между переменными, значение которых: `null`, `undefined` и не объявлено? Как бы вы проверили их на каждое из этих значений?

Необъявленные переменные создаются, когда вы присваиваете значение идентификатору, который не был ранее создан при помощи `var`, `let` или `const`. Необъявленные переменные будут определены глобально, вне текущей области видимости. В строгом режиме будет ошибка `ReferenceError`, когда вы попытаетесь назначить значение необъявленной переменной. Необъявленные переменные плохи так же, как и глобальные переменные.

Переменная `undefined` - это переменная, которая была объявлена, но ей не было присвоено значение. Ее тип `undefined`. Если переменной присвоить функцию, которая не возвращает никакого значения, то переменная также будет иметь значение `undefined`. Либо разработчик сам явно назначал переменной значение `undefined`.

Переменной со значением `null` было явно присвоено значение `null`. Она отличается от `undefined` тем, что она была назначена явно. Чтобы проверить на `null`, просто сравните, используя оператор строгого равенства.

## 8. Что такое замыкание, и как/для чего его используют?

Замыкание - это комбинация функции и лексического окружения, в которой эта функция была объявлена. Слово "лексический" относится к тому факту, что лексическая область видимости использует место, где переменная объявлена в исходном коде, чтобы определить, где эта переменная доступна. Замыкания - это функции, которые имеют доступ к переменным внешней (замыкающей) функции - цепочке областей видимости даже после того, как внешняя функция вернулась.

Для чего оно?
- Конфиденциальность данных / эмуляция скрытых методов при помощи замыканий.
- Частичное применение функций или каррирование.

Пример поярче - React-хуки.

[Источник 1](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures), [Источник 2](https://medium.com/javascript-scene/master-the-javascript-interview-what-is-a-closure-b2f0d2152b36), [Источник 3](https://learn.javascript.ru/closure)

## 9. Можете ли вы описать основное различие между циклом .forEach и циклом .map()? И в каких случаях каждый из них используется?

https://www.frontendinterviewhandbook.com/ru/javascript-questions/#%D0%BC%D0%BE%D0%B6%D0%B5%D1%82%D0%B5-%D0%BB%D0%B8-%D0%B2%D1%8B-%D0%BE%D0%BF%D0%B8%D1%81%D0%B0%D1%82%D1%8C-%D0%BE%D1%81%D0%BD%D0%BE%D0%B2%D0%BD%D0%BE%D0%B5-%D1%80%D0%B0%D0%B7%D0%BB%D0%B8%D1%87%D0%B8%D0%B5-%D0%BC%D0%B5%D0%B6%D0%B4%D1%83-%D1%86%D0%B8%D0%BA%D0%BB%D0%BE%D0%BC-foreach-%D0%B8-%D1%86%D0%B8%D0%BA%D0%BB%D0%BE%D0%BC-map-%D0%B8-%D0%B2-%D0%BA%D0%B0%D0%BA%D0%B8%D1%85-%D1%81%D0%BB%D1%83%D1%87%D0%B0%D1%8F%D1%85-%D0%BA%D0%B0%D0%B6%D0%B4%D1%8B%D0%B9-%D0%B8%D0%B7-%D0%BD%D0%B8%D1%85-%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D1%83%D0%B5%D1%82%D1%81%D1%8F

## 10. В каких случаях обычно используются анонимные функции?

IIFE и колбэки.

## 11. В чем разница между host-объектами и нативными объектами?

Нативные объекты - это объекты, которые являются частью языка JavaScript, определенного в спецификации ECMAScript: `String`, `Math`, `RegExp`, `Object`, `Function` и т.д.

Хост-объекты предоставляются средой выполнения (браузером или Node), такие как `window`, `XMLHTTPRequest` и т.д.

## 12. В чем разница между: `function Person(){}`, `var person = Person()`, и `var person = new Person()`?

Этот вопрос не совсем понятен. Возможно суть вопроса о конструкторах в JavaScript. Строго говоря, `function Person(){}` - это обычное объявление функции. Принято называть с заглавной буквы функции, которые предназначены для использования в качестве конструкторов.

`var person = Person()` вызывает Person как функцию, а не как конструктор. Вызов как таковой является распространенной ошибкой, если функция предназначена для использования в качестве конструктора. Как правило, конструктор ничего не возвращает, поэтому при вызове конструктора как обычной функции возвращается `undefined`, и это присваивается переменной, предназначенной в качестве экземпляра.

`var person = new Person()` создает экземпляр объекта Person с помощью оператора `new`, который наследуется от `Person.prototype`. Альтернативой может быть использование `Object.create`, например: `Object.create(Person.prototype)`.

## 13. В чем разница между `.call` и `.apply`?

Сходство заключается в том, что и `.call`, и `.apply` используются для вызова функций, а также первый параметр будет использоваться как значение `this` внутри функции. А разница в том, что `.call` в качестве следующих аргументов принимает аргументы, разделенные запятыми, в то время как `.apply` в качестве следующих аргументов принимает массив аргументов.

## 14. Что делает и для чего нужна функция `.bind`?

Метод `bind()` создаёт новую функцию, которая при вызове устанавливает в качестве контекста выполнения `this` предоставленное значение. В метод также передаётся набор аргументов, которые будут установлены перед переданными в привязанную функцию аргументами при её вызове.

Частый пример использования: указание контекста для методов в классовом компоненте React.

## 15. В каких случаях используется `document.write()`?

`document.write()` записывает строку текста в поток документа, открытого при помощи `document.open()`. Когда `document.write()` выполняется после загрузки страницы, он вызывает document.open, который очищает весь документ (<head>и<body> будут удалены!) и заменяет содержимое на заданное значение параметра. Подобный подход считается опасным и не рекомендуется его использовать.

## 16. В чём разница между feature detection (определение возможностей браузера), ferature inference (предположение возможностей) и анализом строки user-agent?

### Feature detection

Определение, поддерживает ли браузер определённый блок кода. Если нет, то будет выполняться другой код, что позволит работать коду в разных браузерах. Из всех перечисленных рекомендуется только этот.
```js
if ('geolocation' in navigator) {
  // Можно использовать navigator.geolocation
} else {
  // Обработка отсутствия возможности
}
```

### Feature inference

Предположение возможностей проверяет на наличие определенных возможностей, как и предыдущий подход, но использует другую функцию, которая предполагает, что определенная возможность уже существует.
```js
if (document.getElementsByTagName) {
  element = document.getElementById(id);
}
```

### Строка User Agent

Способ ещё более ненадёжный, основанный на парсинге строки `User-Agent`. В чём заключается ненадёжность:
- Строку может подменить пользователь.
- Строки трудно распарсить (к примеру, Safari и Google Chrome имеют схожие значения, но разница поддерживаемых функций огромна)
- Нужно анализировать и описывать разницу в версиях браузера.

## 17. Расскажите об AJAX

AJAX (Async Javascript And XML) - набор методов веб-разработки, позволяющих создавать асинхронные веб-приложения и приложения, которые работают с данными сервера без перезагрузок и переходов страниц.

Основные API с AJAX: `XMLHttpRequest`, более актуальное `fetch`.

## 18. Какие преимущества и недостатки в использовании Ajax?

https://www.frontendinterviewhandbook.com/ru/javascript-questions/#%D0%BA%D0%B0%D0%BA%D0%B8%D0%B5-%D0%BF%D1%80%D0%B5%D0%B8%D0%BC%D1%83%D1%89%D0%B5%D1%81%D1%82%D0%B2%D0%B0-%D0%B8-%D0%BD%D0%B5%D0%B4%D0%BE%D1%81%D1%82%D0%B0%D1%82%D0%BA%D0%B8-%D0%B2-%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B8-ajax

## 19. Объясните, как работает JSONP (и почему это не совсем AJAX)

https://www.frontendinterviewhandbook.com/ru/javascript-questions/#%D0%BE%D0%B1%D1%8A%D1%8F%D1%81%D0%BD%D0%B8%D1%82%D0%B5-%D0%BA%D0%B0%D0%BA-%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%B0%D0%B5%D1%82-jsonp-%D0%B8-%D0%BF%D0%BE%D1%87%D0%B5%D0%BC%D1%83-%D1%8D%D1%82%D0%BE-%D0%BD%D0%B5-%D1%81%D0%BE%D0%B2%D1%81%D0%B5%D0%BC-ajax

## 20. Вы когда-нибудь использовали шаблонизацию на JavaScript? Если да, то какие библиотеки вы использовали?

Шаблонизация встречается во всех популярных фреймворках и библиотеках для работы с view-частью. Одни из них - тот же Angular со своими HTML-шаблонами и React с JSX.

## 21. Расскажите, что такое поднятие (hoisting)

https://www.frontendinterviewhandbook.com/ru/javascript-questions/#%D1%80%D0%B0%D1%81%D1%81%D0%BA%D0%B0%D0%B6%D0%B8%D1%82%D0%B5-%D1%87%D1%82%D0%BE-%D1%82%D0%B0%D0%BA%D0%BE%D0%B5-%D0%BF%D0%BE%D0%B4%D0%BD%D1%8F%D1%82%D0%B8%D0%B5-hoisting

## 22. Объясните, что такое всплытие событий (event bubbling)

https://www.frontendinterviewhandbook.com/ru/javascript-questions/#%D0%BE%D0%B1%D1%8A%D1%8F%D1%81%D0%BD%D0%B8%D1%82%D0%B5-%D1%87%D1%82%D0%BE-%D1%82%D0%B0%D0%BA%D0%BE%D0%B5-%D0%B2%D1%81%D0%BF%D0%BB%D1%8B%D1%82%D0%B8%D0%B5-%D1%81%D0%BE%D0%B1%D1%8B%D1%82%D0%B8%D0%B9-event-bubbling

## 23. В чем разница между "атрибутом" (attribute) и "свойством" (property)?

Атрибуты определены в разметке HTML, а свойства определены в DOM. Чтобы проиллюстрировать разницу, представьте, что у нас есть это текстовое поле в HTML: `<input type="text" value="Hello">`.
```js
const input = document.querySelector('input');
console.log(input.getAttribute('value')); // Hello
console.log(input.value); // Hello
```

Но после того, как вы измените значение текстового поля, добавив к нему "World!", будет:
```js
console.log(input.getAttribute('value')); // Hello
console.log(input.value); // Hello World!
```

## 24. Почему не следует расширять нативные JavaScript-объекты?

Расширение встроенного/нативного объекта JavaScript означает добавление свойств/функций к его прототипу. Хотя на первый взгляд это может показаться хорошей идеей, на практике это опасно. Представьте, что ваш код использует несколько библиотек, которые расширяют `Array.prototype`, добавляя один и тот же метод `contains`. В результате код будет работать неверно, если поведение этих двух методов не будет одинаковым.

Единственный случай, при котором можно расширить нативный объект - это при создании полифила, создав собственную реализацию метода, который является частью спецификации JavaScript, но может отсутствовать в устаревших браузерах.

## 25. В чем разница между событием `load` и событием `DOMContentLoaded`?

Событие `DOMContentLoaded` вызывается, когда исходный HTML-документ полностью загружен и обработан, не дожидаясь окончания загрузки таблиц стилей, изображений и скриптов.

Событие `load` происходит только после загрузки DOM и всех зависимых ресурсов.

## 26. В чём разница между `==` и `===`?

https://www.frontendinterviewhandbook.com/ru/javascript-questions/#%D0%B2-%D1%87%D0%B5%D0%BC-%D1%80%D0%B0%D0%B7%D0%BD%D0%B8%D1%86%D0%B0-%D0%BC%D0%B5%D0%B6%D0%B4%D1%83--%D0%B8-

## 27. Объясните same-origin policy в контексте JavaScript

Same-origin policy (принцип одинакового источника) не позволяет JavaScript выполнять запросы за границы домена. Источник определяется как комбинация схемы URI, имени хоста и номера порта. Этот принцип не позволяет вредоносному сценарию на одной странице получить доступ к конфиденциальным данным на другой через объектную модель документа этой страницы.

## 28. Сделайте так, чтобы код `duplicate([1, 2, 3, 4, 5]); // [1,2,3,4,5,1,2,3,4,5]` работал

Через `concat()` или спред-оператор.

## 29. Почему тернарный оператор так называется?

Тернарный = три. Три операнда внутри выражения.

## 30. Что делает строчка `"use strict";`? Какие достоинства и недостатки от ее использования?

### Преимущества:
- Не позволяет случайно создавать глобальные переменные.
- Любое присваивание, которое в обычном режиме завершится неудачей, в строгом выдаст ошибку.
- При попытке удалить неудаляемые свойства, выдаст ошибку.
- Требует, чтоббы имена параметров функций были уникальными.
- `this` в глобальной области = `undefined`.
- Перехватывает распространённые ошибки, выдавая исключения.
- Исключает неочевидные особенности языка.

### Недостатки:
- Нельзя использовать некоторые особенности языка, к которым привыкли некоторые разработчики.
- Нет доступа к `function.caller` и `function.arguments`.
- Объединение скриптов, написанных в строгом режиме, может вызвать проблемы.

## 31. Напишите цикл, который перебирает числа до 100, возвращая "fizz" на числа кратные 3, "buzz" на числа кратные 5 и "fizzbuzz" на числа кратные 3 и 5.

```js
for (let i = 1; i <= 100; i++) {
  let f = i % 3 == 0,
    b = i % 5 == 0;
  console.log(f ? (b ? 'FizzBuzz' : 'Fizz') : b ? 'Buzz' : i);
}
```

## 32. Почему считается хорошим тоном оставить глобальную область видимости (global scope) в нетронутом состоянии?

Каждый скрипт имеет доступ к глобальной области видимости, и если каждый будет использовать глобальное пространство имен для определения своих переменных, то могут возникнуть конфликты. Используйте модульный паттерн (используя IIFE) для инкапсуляции ваших переменных в локальное пространство имен.

## 33. Для чего используют событие `load`? Есть ли у этого события недостатки? Знаете ли вы какие-либо альтернативы, и в каких случаях бы стали их использовать?

Событие `load` происходит в конце процесса загрузки документа. На этом этапе все объекты документа находятся в DOM, все изображения, скрипты и ссылки загрузились.

Подобное событие `DOMContentLoaded` будет запущено после создания DOM для страницы, но при этом загрузка остальных ресурсов не важна. Это событие лучше использовать тогда, когда просто нужны манипуляции над DOM.

## 34. Как сделать одностраничное приложение SEO-оптимизированным.

Использование SSR решений типа Next.js.

## 35. Насколько вы опытны в работе с промисами (promises) и/или их полифилами?

https://www.frontendinterviewhandbook.com/ru/javascript-questions#%D0%BD%D0%B0%D1%81%D0%BA%D0%BE%D0%BB%D1%8C%D0%BA%D0%BE-%D0%B2%D1%8B-%D0%BE%D0%BF%D1%8B%D1%82%D0%BD%D1%8B-%D0%B2-%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%B5-%D1%81-%D0%BF%D1%80%D0%BE%D0%BC%D0%B8%D1%81%D0%B0%D0%BC%D0%B8-promises-%D0%B8%D0%B8%D0%BB%D0%B8-%D0%B8%D1%85-%D0%BF%D0%BE%D0%BB%D0%B8%D1%84%D0%B8%D0%BB%D0%B0%D0%BC%D0%B8

## 36. Какие преимущества и недостатки при использовании промисов вместо колбэков (callbacks)?

Преимущества:
- Исключение callback hell, вместо него читаемый `.then()`
- Упрощение создания параллельного асинхронного кода (`Promise.all()` или `Promise.any()`)
- Исключение возможности, что колбэк-функция была вызвана слишком рано, поздно, мало или много раз (???)

## 37. Каковы преимущества и недостатки написания JavaScript-кода на языке, который компилируется в JavaScript?

Преимущества:
- Исправление давних проблемы JS
- Препятствование использования антипаттернов
- Позволяет писать код короче
- Позволяет писать код с типизацией

Недостатки:
- Необходима сборка или компиляция кода
- Отладка может быть затруднённой
- Какие-то разработчики могут быть незнакомы с нестандартными метаязыками
- Меньшее сообщество
- Может отсутствовать поддержка в IDE
- Языки будут всегда позади последнего стандарта JS

## 38. Какие инструменты отладки существуют в JS?

- Для React: React Devtools и Redux Devtools
- Для Vue: Vue Devtools
- Для JS: Chrome Devtools, выражение `debugger` и работа с консолью

## 39. Какие языковые конструкции можно использовать для итерации по свой свойствам объекта и элеметам массива?

Для объектов:
- `for (let property in obj) {}`
- `Object.keys()`, `Object.entries()`, `Object.values()`
- `Object.getOwnPropertyNames()`

Для массивов:
- `for (let i = 0; i < arr.length; i++) {}`
- `forEach()`
- `for (let elem of arr) {}`
- `map()`, `reduce()`, `filter()`

## 40. Объясните разницу между изменяемыми (mutable) и неизменяемыми (immutable) объектами

Изменяемые объекты - объекты, свойства которых могут менять напрямую. Неизменяемые объекты - объекты, для изменения значения которых нужно создавать новый объект.

Иммутабельные данные - выхлоп чистых функций.

Реализовать иммутабельность объектов можно:
- идеологически, предотвращая в коде проекта появление грязных функций
- использование `Object.freeze()`
- Использование сторонних библиотек типа `Seamless-Immutable` или `Immutable.js`

## 41. Объясните разницу между синхронными и асинхронными функциями

- Синхронные функции являются блокирующими, асинхронные - нет
- Асинхронные функции подразумеваются отложенными, синхронные - нет

## 42. Что такое event loop?

Способ распределения асинхронных задач. Порядок такой:
1. Выполняется весь синхронный код.
2. Выполняются все микрозадачи (в них входит mutation observer и promise)
3. Выполняется одна макрозадача (в них входят `setTimeout`, AJAX, `setInterval`, хендлеры событий)
4. Так как синхронный код выполнен, опять возвращаемся ко всем микрозадачам
5. И т.д.

Разбор на примере №1. Следующий код:
```js
setTimeout(function timeout() {
    console.log('Таймаут');
}, 0);

let p = new Promise(function(resolve, reject) {
    console.log('Создание промиса');
    resolve();
});

p.then(function(){
    console.log('Обработка промиса');
});

console.log('Конец скрипта');
```

Выведет:
1. Создание промиса - это входит в синхронный код, так как происходит пока только создание промиса.
2. Конец скрипта - это входит в синхронный код.
3. Обработка промиса - после синхронного кода выполняются все находящиеся в очереди микрозадачи. Здесь это один промис.
4. Таймаут - после всех доступных микрозадач событийный цикл берёт в работу одну макрозадачу. Это таймаут.

Пример №2. Следующий код:
```js
console.log(1);
// Первая строка выполняется сразу и выводит `1`.
// Очереди микрозадач и макрозадач на данный момент пусты.

setTimeout(() => console.log(2));
// `setTimeout` ставит переданный колбэк в очередь макрозадач
// - содержимое очереди макрозадач:
//   `console.log(2)`

Promise.resolve().then(() => console.log(3));
// В очередь микрозадач ставится колбэк, выводящий `3`
// - содержимое очереди микрозадач:
//   `console.log(3)`

Promise.resolve().then(() => setTimeout(() => console.log(4)));
// В очередь микрозадач ставится колбэк с `setTimeout`
// - содержимое очереди микрозадач:
//   `console.log(3); setTimeout(...4)`

Promise.resolve().then(() => console.log(5));
// В очередь микрозадач ставится колбэк, выводящий `5`
// - содержимое очереди микрозадач:
//   `console.log(3); setTimeout(...4); console.log(5)`

setTimeout(() => console.log(6));
// `setTimeout` ставит переданный колбэк в очередь макрозадач
// - содержимое очереди макрозадач:
//   `console.log(2); console.log(6)`

console.log(7);
// Тут же выводит `7`.
```

Выведет:
1. 1
2. 7
3. 3
4. 5
5. 2
6. 6
7. 4

## 43. Объясните разницу между `function foo() {}` и `var foo = function() {}` при объявлении в одинаковых условиях.

`function foo() {}` поднимется целиком, `var foo = function() {}` поднимется только объявление переменной, сама функция будет недоступной до места инициализации.

## 44. В чём разница между `var`, `let` и `const`?

- Переменные `var` относятся к области видимости функции или к глобальному объекту, если созданы вне функции.
- `let` и `const` относятся к блочной области видимости.
- `var` обладает свойством поднятия.
- Переопределение `var` с ключевым словом возможно, `let` и `const` - нет.

## 45. В чем разница между классом в ES6 и функцией-конструктором в ES5?

Основная суть в описании наследования. Вот как выглядят классы на ES6 с наследованием:
```js
class Person {
  constructor(name) {
    this.name = name;
  }
}

class Student extends Person {
  constructor(name, studentId) {
    super(name);
    this.studentId = studentId;
  }
}
```

А вот как выглядит наследование на прототипах:
```js
// Shape - superclass
// x,y: location of shape's bounding rectangle
function Shape(x, y) {
  this.x = x;
  this.y = y;
}

// Superclass method
Shape.prototype.move = function(x, y) {
  this.x += x;
  this.y += y;
}

// Circle - subclass
function Circle(x, y, r) {
  // Call constructor of superclass to initialize superclass-derived members.
  Shape.call(this, x, y);

  // Initialize subclass's own members
  this.r = r;
}

// Circle derives from Shape
Circle.prototype = Object.create(Shape.prototype);
Circle.prototype.constructor = Circle;

// Subclass methods. Add them after Circle.prototype is created with
// Object.create
Circle.prototype.circumference = function() {
  return this.r * 2 * Math.PI;
}
```

## 46. Можете ли вы привести пример использования стрелочных функции =>? Чем они отличаются от других функций?

Я лично не вижу уже смысла от обычных функций. Они были полезны своим контекстом и возмжожностью описания класса на прототипах, сейчас это уже устарело.

## 47. В чем преимущество использования стрелочных функций для метода в конструкторе?

Изолирование контекста `this` от возможных изменений.

## 48. Что такое функции высшего порядка

Это функции, которые в качестве аргументов принимают другие функции и возвращают модифицированные функции. Классический пример: методы `map()`, `forEach()`, `filter()` и т.д.

## 49. Можете ли вы привести пример деструктуризации объекта или массива?

https://www.frontendinterviewhandbook.com/ru/javascript-questions#%D0%BC%D0%BE%D0%B6%D0%B5%D1%82%D0%B5-%D0%BB%D0%B8-%D0%B2%D1%8B-%D0%BF%D1%80%D0%B8%D0%B2%D0%B5%D1%81%D1%82%D0%B8-%D0%BF%D1%80%D0%B8%D0%BC%D0%B5%D1%80-%D0%B4%D0%B5%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D0%B8-%D0%BE%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%B0-%D0%B8%D0%BB%D0%B8-%D0%BC%D0%B0%D1%81%D1%81%D0%B8%D0%B2%D0%B0

## 50. Шаблонные строки в ES6 намного упрощают создание строк, можете ли вы привести пример их использования?

https://www.frontendinterviewhandbook.com/ru/javascript-questions#%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D0%BD%D1%8B%D0%B5-%D1%81%D1%82%D1%80%D0%BE%D0%BA%D0%B8-%D0%B2-es6-%D0%BD%D0%B0%D0%BC%D0%BD%D0%BE%D0%B3%D0%BE-%D1%83%D0%BF%D1%80%D0%BE%D1%89%D0%B0%D1%8E%D1%82-%D1%81%D0%BE%D0%B7%D0%B4%D0%B0%D0%BD%D0%B8%D0%B5-%D1%81%D1%82%D1%80%D0%BE%D0%BA-%D0%BC%D0%BE%D0%B6%D0%B5%D1%82%D0%B5-%D0%BB%D0%B8-%D0%B2%D1%8B-%D0%BF%D1%80%D0%B8%D0%B2%D0%B5%D1%81%D1%82%D0%B8-%D0%BF%D1%80%D0%B8%D0%BC%D0%B5%D1%80-%D0%B8%D1%85-%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F

## 51. Можете ли вы привести пример каррированной функции (curry function) и в чем их преимущество?

https://www.frontendinterviewhandbook.com/ru/javascript-questions#%D0%BC%D0%BE%D0%B6%D0%B5%D1%82%D0%B5-%D0%BB%D0%B8-%D0%B2%D1%8B-%D0%BF%D1%80%D0%B8%D0%B2%D0%B5%D1%81%D1%82%D0%B8-%D0%BF%D1%80%D0%B8%D0%BC%D0%B5%D1%80-%D0%BA%D0%B0%D1%80%D1%80%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D0%BE%D0%B9-%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%B8-curry-function-%D0%B8-%D0%B2-%D1%87%D0%B5%D0%BC-%D0%B8%D1%85-%D0%BF%D1%80%D0%B5%D0%B8%D0%BC%D1%83%D1%89%D0%B5%D1%81%D1%82%D0%B2%D0%BE

## 52. В чем преимущества использования spread оператора и чем он отличается от rest оператора?

- Spread-оператор - "расслаивание" массива или объекта для использования его оставшихся объектов (деструктуризация объекта или массива).
- Rest-оператор - объединение неизвестного количества элементов в массив (объединение аргументов).

## 53. Каким образом можно обмениваться кодом между файлами?

https://www.frontendinterviewhandbook.com/ru/javascript-questions#%D0%BA%D0%B0%D0%BA%D0%B8%D0%BC-%D0%BE%D0%B1%D1%80%D0%B0%D0%B7%D0%BE%D0%BC-%D0%BC%D0%BE%D0%B6%D0%BD%D0%BE-%D0%BE%D0%B1%D0%BC%D0%B5%D0%BD%D0%B8%D0%B2%D0%B0%D1%82%D1%8C%D1%81%D1%8F-%D0%BA%D0%BE%D0%B4%D0%BE%D0%BC-%D0%BC%D0%B5%D0%B6%D0%B4%D1%83-%D1%84%D0%B0%D0%B9%D0%BB%D0%B0%D0%BC%D0%B8

## 54. Для чего используются статические члены класса?

https://www.frontendinterviewhandbook.com/ru/javascript-questions#%D0%B4%D0%BB%D1%8F-%D1%87%D0%B5%D0%B3%D0%BE-%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D1%83%D1%8E%D1%82%D1%81%D1%8F-%D1%81%D1%82%D0%B0%D1%82%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5-%D1%87%D0%BB%D0%B5%D0%BD%D1%8B-%D0%BA%D0%BB%D0%B0%D1%81%D1%81%D0%B0

## 55. Какие есть способы создания объекта?

- `new Object()`
- `Object.create(null)`
- `{}`
- Конструтор function:
```js
function Person(name) {
  this.name = name;
  this.age = 21;
}
var object = new Person("Sudheer");

function Person() {}
Person.prototype.name = "Sudheer";
var object = new Person();
```

- Создание экземпляра класса:
```js
class Person {
  constructor(name) {
    this.name = name;
  }
}

var object = new Person("Sudheer");
```

- Синглтон на создание объекта:
```js
var object = new (function () {
  this.name = "Sudheer";
})();
```

## 56. Для чего метод `slice()` у массивов?

Этот метод возвращает кусок массива с указанным начальным и конечным индексом.

```js
let arrayIntegers = [1, 2, 3, 4, 5];
let arrayIntegers1 = arrayIntegers.slice(0, 2); // returns [1,2]
let arrayIntegers2 = arrayIntegers.slice(2, 3); // returns [3]
let arrayIntegers3 = arrayIntegers.slice(4); //returns [5]
```

## 57. Для чего метод `splice()` у массивов?

Это швейцарский нож для работы с массивами. Он позволяет удалять и добавлять элементы в массив.

```js
let arrayIntegersOriginal1 = [1, 2, 3, 4, 5];
let arrayIntegersOriginal2 = [1, 2, 3, 4, 5];
let arrayIntegersOriginal3 = [1, 2, 3, 4, 5];

let arrayIntegers1 = arrayIntegersOriginal1.splice(0, 2); // returns [1, 2]; original array: [3, 4, 5]
let arrayIntegers2 = arrayIntegersOriginal2.splice(3); // returns [4, 5]; original array: [1, 2, 3]
let arrayIntegers3 = arrayIntegersOriginal3.splice(3, 1, "a", "b", "c"); //returns [4]; original array: [1, 2, 3, "a", "b", "c", 5]
```

## 58. В чём разница между `slice()` и `splice()`?

https://github.com/sudheerj/javascript-interview-questions#what-is-the-difference-between-slice-and-splice

## 59. В чём схожесть и различие `Object` и `Map`?

### Сходства:
- Оба имеют доступ к значениям по ключам.
- Имеют возможность удаления ключей.
- Имеет возможность обнаружения, занят ли ключ, имеется ли значение по ключам.

### Различия:
- Ключами в объекте могут быть только строки и символы, в Map - что угодно.
- Ключи в Map имеют сортировку по порядку добавления, у объекта нет явного порядка ключей.
- Размер Map можно легко получить свойством размера, у объекта нужно выяснять "самому".
- Map - итерируемый экземпляр.
- Объект может иметь прототип.
- Map лучше по производительности при частом добавлении или удалении ключей со значениями.

## Источники:

- [Frontend Interview Handbook](https://www.frontendinterviewhandbook.com/ru/javascript-questions/)