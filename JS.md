# Вопросы:
1. [Объясните делегирование событий](#1-объясните-делегирование-событий)
2. [Объясните, как работает this](#2-объясните-как-работает-this)
3. [Расскажите, как работает прототипное наследование](#3-расскажите-как-работает-прототипное-наследование)
4. [В чём разница между `__proto__`, `prototype` и оператором `new`?](#4-в-чём-разница-между-proto-prototype-и-оператором-new)
5. [Что вы думаете о AMD против CommonJS?](#5-что-вы-думаете-о-amd-против-commonjs)
6. [Объясните, почему это не является IIFE: function foo(){ }();. Что необходимо изменить, чтобы это стало IIFE?](#6-объясните-почему-это-не-является-iife-function-foo--что-необходимо-изменить-чтобы-это-стало-iife)
7. [В чем различие между переменными, значение которых: `null`, `undefined` и не объявлено? Как бы вы проверили их на каждое из этих значений?](#7-в-чем-различие-между-переменными-значение-которых-null-undefined-и-не-объявлено-как-бы-вы-проверили-их-на-каждое-из-этих-значений)
8. [Что такое замыкание и как/для чего его используют?](#8-что-такое-замыкание-и-какдля-чего-его-используют)
9. [Можете ли вы описать основное различие между циклом .forEach и циклом .map()? И в каких случаях каждый из них используется?](#9-можете-ли-вы-описать-основное-различие-между-циклом-foreach-и-циклом-map-и-в-каких-случаях-каждый-из-них-используется)
10. [В каких случаях обычно используются анонимные функции?](#10-в-каких-случаях-обычно-используются-анонимные-функции)
11. [В чем разница между host-объектами и нативными объектами?](#11-в-чем-разница-между-host-объектами-и-нативными-объектами)
12. [В чем разница между: `function Person(){}`, `var person = Person()`, и `var person = new Person()`?](#12-в-чем-разница-между-function-person-var-person--person-и-var-person--new-person)
13. [В чем разница между `.call` и `.apply`?](#13-в-чем-разница-между-call-и-apply)
14. [Что делает и для чего нужна функция `.bind`?](#14-что-делает-и-для-чего-нужна-функция-bind)
15. [В каких случаях используется `document.write()`?](#15-в-каких-случаях-используется-documentwrite)

## 1. Объясните делегирование событий

Делегирование событий - это приём, заключающийся в добавлении обработчиков событий к родительскому элементу, а не к дочерним элементам. Обработчик будет срабатывать всякий раз, когда событие будет запущено на дочерних элементах благодаря всплытию событий в DOM. Преимущества этого приёма:
- Экономит объем используемой памяти, т.к. для родительского элемента требуется только один обработчик.
- Не нужно привязывать или убирать обработчики при добавлении и удалении элементов.

[Источник 1](https://davidwalsh.name/event-delegate), [Источник 2](https://stackoverflow.com/questions/1687296/what-is-dom-event-delegation)

## 2. Объясните, как работает this

Нельзя в двух словах объяснить, как работает `this` - это одно из самых запутанных понятий в JS. Значение `this` зависит от того, как вызывается функция.

Есть следующие правила определения, чем является `this`:
- Если используется ключевое слово `new` при вызове функции, `this` внутри функции будет новым объектом.
- Если для вызова или создания функции используются методы `bind`, `call` или `apply`, то `this` внутри функции - это объект, который передали в качестве аргумента.
- Если функция вызывается как метод (`obj.method()`), то `this` - это объект, к которому принадлежит функция (метод).
- Если функция вызывается без контекста, то есть без условий, описанных выше, то в браузере `this` - это объект `window`. В строгом режиме (`use strict`) `this` будет `undefined` вместо глобального объекта.
- Если применяется несколько из вышеперечисленных правил, то правило, которое выше, имеет приоритет.
- Если функция является стрелочной функцией, то она игнорирует все вышеописанные правила и получает значения `this` из лексического окружения во время её создания.

[Источник 1](https://codeburst.io/the-simple-rules-to-this-in-javascript-35d97f31bde3), [Источник 2](https://stackoverflow.com/a/3127440/1751946)

## 3. Расскажите, как работает прототипное наследование

Все объекты в JavaScript имеют свойство `__proto__`, которое является ссылкой на другой объект. Когда происходит обращение к свойству объекта, и если свойство не найдено в этом объекте, то механизм JavaScript просматривает прототип объекта, затем прототип прототипа и т.д. До тех пор, пока не найдет определенное свойство на одном из прототипов или до тех пор, пока он не достигнет конца цепочки прототипов. Такое поведение имитирует классическое наследование, но на самом деле это скорее делегирование, чем наследование.

## 4. В чём разница между `__proto__`, `prototype` и оператором `new`?

#### Свойство `__proto__`

Абсолютно любой объект в JavaScript имеет свойство `__proto__`. Это скрытое системное свойство, и не во всех реализациях языка оно доступно пользователю. При обращении к любому свойству объекта, оно в первую очередь ищется в самом объекте. Но если его там нет, поиск происходит в свойстве `__proto__`. Если его нет и там, оно ищется дальше по цепочке. Эта цепочка называется цепочкой прототипов (prototype chain). Последнее звено `__proto__` всегда равно `null`.

#### Свойство `prototype`

Это обычное свойство, ничем не отличающиеся от любых других свойств. За исключением двух особенностей:
1. Функции в JavaScript имеют свойство `prototype`. Оно по умолчанию является объектом с единственным свойством constructor, которое ссылается на саму функцию.
2. Свойство `prototype` используется при создании новых объектов оператором `new`.

#### Оператор `new`

Оператор делает следующее:
1. Создаёт пустой объект.
```js
var instance = {};
```

2. Устанавливает `__proto__` этому объекту ссылкой на `prototype` функции-класса:
```js
instance.__proto__ = FnClass.prototype;
```

3. Применяет функцию-класс к нашему новосозданному объекту, т.е. исполняет функцию `FnClass`, передавая ей `instance` в качестве `this` и аргументы в виде массива `arguments`:
```js
constructorReturns = FnClass.apply(instance, arguments);
```

4. Возвращает экземпляр функции-класса, но если `FnClass` нам вернул обьект, тогда его:
```js
return constructorReturns instanceof Object ? constructorReturns : instance;
```

Функцией-классом я называю функцию, к которой впоследствии ожидается применение оператора new. Такие функции принято именовать с заглавной буквы.

## 5. Что вы думаете о AMD против CommonJS?

Оба являются способами реализации системы модулей до появления ES2015 и его нативной системы модулей. CommonJS является синхронным, а AMD (Async Module Definition) - асинхронным. CommonJS разработан с учётом разработки на стороне сервера, в то время как AMD с поддержкой асинхронной загрузки модулей больше предназначен для браузеров.

AMD можно считать ненужным из-за асинхронности, которой никто может и не воспользоваться. При этом CommonJS ближе к стилю модулей Node, что даёт меньше путаницы при переключении между клиентской и серверной разработкой.

[Источник 1](https://auth0.com/blog/javascript-module-systems-showdown/), [Источник 2](https://stackoverflow.com/questions/16521471/relation-between-commonjs-amd-and-requirejs)

## 6. Объясните, почему это не является IIFE: function foo(){ }();. Что необходимо изменить, чтобы это стало IIFE?

IIFE расшифровывается как Immediately Invoked Function Expression - немедленно вызываемое функциональное выражение. Синтаксический анализатор JavaScript читает `function foo(){ } ();` как `function foo(){ }` и `();`, где первое выражение - это объявление функции, а второе (пара скобок) - попытка вызова функции, но так как имя не указано, он выдает ошибку `Uncaught SyntaxError: Unexpected token`.

Вот два способа исправить это, которые заключаются добавление дополнительных скобок: `(function foo(){ })()` и `(function foo(){ }())`. Выражения, начинающиеся с `function`, считаются объявлениями функций. Оборачивая эту функцию внутри `()`, она становится функциональным выражением, которое затем может быть выполнено с последующим `()`. Подобные функции не отображаются в глобальной области видимости, и вы можете даже не указывать им имя, если вы не будете на них ссылаться.

Вы также можете использовать оператор `void` - `void function foo(){ }()`. К сожалению, с таким подходом есть одна проблема. Выполнение данного выражения всегда возвращает `undefined`, поэтому, если ваше IIFE возвращает что-либо, вы не можете его использовать.

## 7. В чем различие между переменными, значение которых: `null`, `undefined` и не объявлено? Как бы вы проверили их на каждое из этих значений?

Необъявленные переменные создаются, когда вы присваиваете значение идентификатору, который не был ранее создан при помощи `var`, `let` или `const`. Необъявленные переменные будут определены глобально, вне текущей области видимости. В строгом режиме будет ошибка `ReferenceError`, когда вы попытаетесь назначить значение необъявленной переменной. Необъявленные переменные плохи так же, как и глобальные переменные.

Переменная `undefined` - это переменная, которая была объявлена, но ей не было присвоено значение. Ее тип `undefined`. Если переменной присвоить функцию, которая не возвращает никакого значения, то переменная также будет иметь значение `undefined`. Либо разработчик сам явно назначал переменной значение `undefined`.

Переменной со значением `null` было явно присвоено значение `null`. Она отличается от `undefined` тем, что она была назначена явно. Чтобы проверить на `null`, просто сравните, используя оператор строгого равенства.

## 8. Что такое замыкание, и как/для чего его используют?

Замыкание - это комбинация функции и лексического окружения, в которой эта функция была объявлена. Слово "лексический" относится к тому факту, что лексическая область видимости использует место, где переменная объявлена в исходном коде, чтобы определить, где эта переменная доступна. Замыкания - это функции, которые имеют доступ к переменным внешней (замыкающей) функции - цепочке областей видимости даже после того, как внешняя функция вернулась.

Для чего оно?
- Конфиденциальность данных / эмуляция скрытых методов при помощи замыканий.
- Частичное применение функций или каррирование.

Пример поярче - React-хуки.

[Источник 1](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures), [Источник 2](https://medium.com/javascript-scene/master-the-javascript-interview-what-is-a-closure-b2f0d2152b36), [Источник 3](https://learn.javascript.ru/closure)

## 9. Можете ли вы описать основное различие между циклом .forEach и циклом .map()? И в каких случаях каждый из них используется?

https://www.frontendinterviewhandbook.com/ru/javascript-questions/#%D0%BC%D0%BE%D0%B6%D0%B5%D1%82%D0%B5-%D0%BB%D0%B8-%D0%B2%D1%8B-%D0%BE%D0%BF%D0%B8%D1%81%D0%B0%D1%82%D1%8C-%D0%BE%D1%81%D0%BD%D0%BE%D0%B2%D0%BD%D0%BE%D0%B5-%D1%80%D0%B0%D0%B7%D0%BB%D0%B8%D1%87%D0%B8%D0%B5-%D0%BC%D0%B5%D0%B6%D0%B4%D1%83-%D1%86%D0%B8%D0%BA%D0%BB%D0%BE%D0%BC-foreach-%D0%B8-%D1%86%D0%B8%D0%BA%D0%BB%D0%BE%D0%BC-map-%D0%B8-%D0%B2-%D0%BA%D0%B0%D0%BA%D0%B8%D1%85-%D1%81%D0%BB%D1%83%D1%87%D0%B0%D1%8F%D1%85-%D0%BA%D0%B0%D0%B6%D0%B4%D1%8B%D0%B9-%D0%B8%D0%B7-%D0%BD%D0%B8%D1%85-%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D1%83%D0%B5%D1%82%D1%81%D1%8F

## 10. В каких случаях обычно используются анонимные функции?

IIFE и колбэки.

## 11. В чем разница между host-объектами и нативными объектами?

Нативные объекты - это объекты, которые являются частью языка JavaScript, определенного в спецификации ECMAScript: `String`, `Math`, `RegExp`, `Object`, `Function` и т.д.

Хост-объекты предоставляются средой выполнения (браузером или Node), такие как `window`, `XMLHTTPRequest` и т.д.

## 12. В чем разница между: `function Person(){}`, `var person = Person()`, и `var person = new Person()`?

Этот вопрос не совсем понятен. Возможно суть вопроса о конструкторах в JavaScript. Строго говоря, `function Person(){}` - это обычное объявление функции. Принято называть с заглавной буквы функции, которые предназначены для использования в качестве конструкторов.

`var person = Person()` вызывает Person как функцию, а не как конструктор. Вызов как таковой является распространенной ошибкой, если функция предназначена для использования в качестве конструктора. Как правило, конструктор ничего не возвращает, поэтому при вызове конструктора как обычной функции возвращается `undefined`, и это присваивается переменной, предназначенной в качестве экземпляра.

`var person = new Person()` создает экземпляр объекта Person с помощью оператора `new`, который наследуется от `Person.prototype`. Альтернативой может быть использование `Object.create`, например: `Object.create(Person.prototype)`.

## 13. В чем разница между `.call` и `.apply`?

Сходство заключается в том, что и `.call`, и `.apply` используются для вызова функций, а также первый параметр будет использоваться как значение `this` внутри функции. А разница в том, что `.call` в качестве следующих аргументов принимает аргументы, разделенные запятыми, в то время как `.apply` в качестве следующих аргументов принимает массив аргументов.

## 14. Что делает и для чего нужна функция `.bind`?

Метод `bind()` создаёт новую функцию, которая при вызове устанавливает в качестве контекста выполнения `this` предоставленное значение. В метод также передаётся набор аргументов, которые будут установлены перед переданными в привязанную функцию аргументами при её вызове.

Частый пример использования: указание контекста для методов в классовом компоненте React.

## 15. В каких случаях используется `document.write()`?

`document.write()` записывает строку текста в поток документа, открытого при помощи `document.open()`. Когда `document.write()` выполняется после загрузки страницы, он вызывает document.open, который очищает весь документ (<head>и<body> будут удалены!) и заменяет содержимое на заданное значение параметра. Подобный подход считается опасным и не рекомендуется его использовать.

## Источники:

- [Frontend Interview Handbook](https://www.frontendinterviewhandbook.com/ru/javascript-questions/)