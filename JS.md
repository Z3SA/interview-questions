# Вопросы:
1. [Объясните делегирование событий](#1-объясните-делегирование-событий)
2. [Объясните, как работает this](#2-объясните-как-работает-this)
3. [Расскажите, как работает прототипное наследование](#3-расскажите-как-работает-прототипное-наследование)
4. [В чём разница между `__proto__`, `prototype` и оператором `new`?](#4-в-чём-разница-между-proto-prototype-и-оператором-new)
5. [Что вы думаете о AMD против CommonJS?](#5-что-вы-думаете-о-amd-против-commonjs)
6. [Объясните, почему это не является IIFE: function foo(){ }();. Что необходимо изменить, чтобы это стало IIFE?](#6-объясните-почему-это-не-является-iife-function-foo--что-необходимо-изменить-чтобы-это-стало-iife)
7. [В чем различие между переменными, значение которых: `null`, `undefined` и не объявлено? Как бы вы проверили их на каждое из этих значений?](#7-в-чем-различие-между-переменными-значение-которых-null-undefined-и-не-объявлено-как-бы-вы-проверили-их-на-каждое-из-этих-значений)
8. [Что такое замыкание и как/для чего его используют?](#8-что-такое-замыкание-и-какдля-чего-его-используют)
9. [Можете ли вы описать основное различие между циклом .forEach и циклом .map()? И в каких случаях каждый из них используется?](#9-можете-ли-вы-описать-основное-различие-между-циклом-foreach-и-циклом-map-и-в-каких-случаях-каждый-из-них-используется)
10. [В каких случаях обычно используются анонимные функции?](#10-в-каких-случаях-обычно-используются-анонимные-функции)
11. [В чем разница между host-объектами и нативными объектами?](#11-в-чем-разница-между-host-объектами-и-нативными-объектами)
12. [В чем разница между: `function Person(){}`, `var person = Person()`, и `var person = new Person()`?](#12-в-чем-разница-между-function-person-var-person--person-и-var-person--new-person)
13. [В чем разница между `.call` и `.apply`?](#13-в-чем-разница-между-call-и-apply)
14. [Что делает и для чего нужна функция `.bind`?](#14-что-делает-и-для-чего-нужна-функция-bind)
15. [В каких случаях используется `document.write()`?](#15-в-каких-случаях-используется-documentwrite)
16. [В чём разница между feature detection (определение возможностей браузера), ferature inference (предположение возможностей) и анализом строки user-agent?](#16-в-чём-разница-между-feature-detection-определение-возможностей-браузера-ferature-inference-предположение-возможностей-и-анализом-строки-user-agent)
17. [Расскажите об AJAX](#17-расскажите-об-ajax)
18. [Какие преимущества и недостатки в использовании Ajax?](#18-какие-преимущества-и-недостатки-в-использовании-ajax)
19. [Объясните, как работает JSONP (и почему это не совсем AJAX)](#19-объясните-как-работает-jsonp-и-почему-это-не-совсем-ajax)
20. [Вы когда-нибудь использовали шаблонизацию на JavaScript? Если да, то какие библиотеки вы использовали?](#20-вы-когда-нибудь-использовали-шаблонизацию-на-javascript-если-да-то-какие-библиотеки-вы-использовали)
21. [Расскажите, что такое поднятие (hoisting)](#21-расскажите-что-такое-поднятие-hoisting)
22. [Объясните, что такое всплытие событий (event bubbling)](#22-объясните-что-такое-всплытие-событий-event-bubbling)
23. [В чем разница между "атрибутом" (attribute) и "свойством" (property)?](#23-в-чем-разница-между-"атрибутом"-attribute-и-"свойством"-property)
24. [Почему не следует расширять нативные JavaScript-объекты?](#24-почему-не-следует-расширять-нативные-javascript-объекты)
25. [В чем разница между событием `load` и событием `DOMContentLoaded`?](#25-в-чем-разница-между-событием-load-и-событием-domcontentloaded)
26. [В чём разница между `==` и `===`?](#26-в-чём-разница-между--и)
27. [Объясните same-origin policy в контексте JavaScript](#27-объясните-same-origin-policy-в-контексте-javascript)
28. [Сделайте так, чтобы код `duplicate([1, 2, 3, 4, 5]); // [1,2,3,4,5,1,2,3,4,5]` работал](#28)
29. [Почему тернарный оператор так называется?](#29-почему-тернарный-оператор-так-называется)
30. [Что делает строчка `"use strict";`? Какие достоинства и недостатки от ее использования?](#30-что-делает-строчка-"use-strict"-какие-достоинства-и-недостатки-от-ее-использования)

## 1. Объясните делегирование событий

Делегирование событий - это приём, заключающийся в добавлении обработчиков событий к родительскому элементу, а не к дочерним элементам. Обработчик будет срабатывать всякий раз, когда событие будет запущено на дочерних элементах благодаря всплытию событий в DOM. Преимущества этого приёма:
- Экономит объем используемой памяти, т.к. для родительского элемента требуется только один обработчик.
- Не нужно привязывать или убирать обработчики при добавлении и удалении элементов.

[Источник 1](https://davidwalsh.name/event-delegate), [Источник 2](https://stackoverflow.com/questions/1687296/what-is-dom-event-delegation)

## 2. Объясните, как работает this

Нельзя в двух словах объяснить, как работает `this` - это одно из самых запутанных понятий в JS. Значение `this` зависит от того, как вызывается функция.

Есть следующие правила определения, чем является `this`:
- Если используется ключевое слово `new` при вызове функции, `this` внутри функции будет новым объектом.
- Если для вызова или создания функции используются методы `bind`, `call` или `apply`, то `this` внутри функции - это объект, который передали в качестве аргумента.
- Если функция вызывается как метод (`obj.method()`), то `this` - это объект, к которому принадлежит функция (метод).
- Если функция вызывается без контекста, то есть без условий, описанных выше, то в браузере `this` - это объект `window`. В строгом режиме (`use strict`) `this` будет `undefined` вместо глобального объекта.
- Если применяется несколько из вышеперечисленных правил, то правило, которое выше, имеет приоритет.
- Если функция является стрелочной функцией, то она игнорирует все вышеописанные правила и получает значения `this` из лексического окружения во время её создания.

[Источник 1](https://codeburst.io/the-simple-rules-to-this-in-javascript-35d97f31bde3), [Источник 2](https://stackoverflow.com/a/3127440/1751946)

## 3. Расскажите, как работает прототипное наследование

Все объекты в JavaScript имеют свойство `__proto__`, которое является ссылкой на другой объект. Когда происходит обращение к свойству объекта, и если свойство не найдено в этом объекте, то механизм JavaScript просматривает прототип объекта, затем прототип прототипа и т.д. До тех пор, пока не найдет определенное свойство на одном из прототипов или до тех пор, пока он не достигнет конца цепочки прототипов. Такое поведение имитирует классическое наследование, но на самом деле это скорее делегирование, чем наследование.

## 4. В чём разница между `__proto__`, `prototype` и оператором `new`?

#### Свойство `__proto__`

Абсолютно любой объект в JavaScript имеет свойство `__proto__`. Это скрытое системное свойство, и не во всех реализациях языка оно доступно пользователю. При обращении к любому свойству объекта, оно в первую очередь ищется в самом объекте. Но если его там нет, поиск происходит в свойстве `__proto__`. Если его нет и там, оно ищется дальше по цепочке. Эта цепочка называется цепочкой прототипов (prototype chain). Последнее звено `__proto__` всегда равно `null`.

#### Свойство `prototype`

Это обычное свойство, ничем не отличающиеся от любых других свойств. За исключением двух особенностей:
1. Функции в JavaScript имеют свойство `prototype`. Оно по умолчанию является объектом с единственным свойством constructor, которое ссылается на саму функцию.
2. Свойство `prototype` используется при создании новых объектов оператором `new`.

#### Оператор `new`

Оператор делает следующее:
1. Создаёт пустой объект.
```js
var instance = {};
```

2. Устанавливает `__proto__` этому объекту ссылкой на `prototype` функции-класса:
```js
instance.__proto__ = FnClass.prototype;
```

3. Применяет функцию-класс к нашему новосозданному объекту, т.е. исполняет функцию `FnClass`, передавая ей `instance` в качестве `this` и аргументы в виде массива `arguments`:
```js
constructorReturns = FnClass.apply(instance, arguments);
```

4. Возвращает экземпляр функции-класса, но если `FnClass` нам вернул обьект, тогда его:
```js
return constructorReturns instanceof Object ? constructorReturns : instance;
```

Функцией-классом я называю функцию, к которой впоследствии ожидается применение оператора new. Такие функции принято именовать с заглавной буквы.

## 5. Что вы думаете о AMD против CommonJS?

Оба являются способами реализации системы модулей до появления ES2015 и его нативной системы модулей. CommonJS является синхронным, а AMD (Async Module Definition) - асинхронным. CommonJS разработан с учётом разработки на стороне сервера, в то время как AMD с поддержкой асинхронной загрузки модулей больше предназначен для браузеров.

AMD можно считать ненужным из-за асинхронности, которой никто может и не воспользоваться. При этом CommonJS ближе к стилю модулей Node, что даёт меньше путаницы при переключении между клиентской и серверной разработкой.

[Источник 1](https://auth0.com/blog/javascript-module-systems-showdown/), [Источник 2](https://stackoverflow.com/questions/16521471/relation-between-commonjs-amd-and-requirejs)

## 6. Объясните, почему это не является IIFE: function foo(){ }();. Что необходимо изменить, чтобы это стало IIFE?

IIFE расшифровывается как Immediately Invoked Function Expression - немедленно вызываемое функциональное выражение. Синтаксический анализатор JavaScript читает `function foo(){ } ();` как `function foo(){ }` и `();`, где первое выражение - это объявление функции, а второе (пара скобок) - попытка вызова функции, но так как имя не указано, он выдает ошибку `Uncaught SyntaxError: Unexpected token`.

Вот два способа исправить это, которые заключаются добавление дополнительных скобок: `(function foo(){ })()` и `(function foo(){ }())`. Выражения, начинающиеся с `function`, считаются объявлениями функций. Оборачивая эту функцию внутри `()`, она становится функциональным выражением, которое затем может быть выполнено с последующим `()`. Подобные функции не отображаются в глобальной области видимости, и вы можете даже не указывать им имя, если вы не будете на них ссылаться.

Вы также можете использовать оператор `void` - `void function foo(){ }()`. К сожалению, с таким подходом есть одна проблема. Выполнение данного выражения всегда возвращает `undefined`, поэтому, если ваше IIFE возвращает что-либо, вы не можете его использовать.

## 7. В чем различие между переменными, значение которых: `null`, `undefined` и не объявлено? Как бы вы проверили их на каждое из этих значений?

Необъявленные переменные создаются, когда вы присваиваете значение идентификатору, который не был ранее создан при помощи `var`, `let` или `const`. Необъявленные переменные будут определены глобально, вне текущей области видимости. В строгом режиме будет ошибка `ReferenceError`, когда вы попытаетесь назначить значение необъявленной переменной. Необъявленные переменные плохи так же, как и глобальные переменные.

Переменная `undefined` - это переменная, которая была объявлена, но ей не было присвоено значение. Ее тип `undefined`. Если переменной присвоить функцию, которая не возвращает никакого значения, то переменная также будет иметь значение `undefined`. Либо разработчик сам явно назначал переменной значение `undefined`.

Переменной со значением `null` было явно присвоено значение `null`. Она отличается от `undefined` тем, что она была назначена явно. Чтобы проверить на `null`, просто сравните, используя оператор строгого равенства.

## 8. Что такое замыкание, и как/для чего его используют?

Замыкание - это комбинация функции и лексического окружения, в которой эта функция была объявлена. Слово "лексический" относится к тому факту, что лексическая область видимости использует место, где переменная объявлена в исходном коде, чтобы определить, где эта переменная доступна. Замыкания - это функции, которые имеют доступ к переменным внешней (замыкающей) функции - цепочке областей видимости даже после того, как внешняя функция вернулась.

Для чего оно?
- Конфиденциальность данных / эмуляция скрытых методов при помощи замыканий.
- Частичное применение функций или каррирование.

Пример поярче - React-хуки.

[Источник 1](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures), [Источник 2](https://medium.com/javascript-scene/master-the-javascript-interview-what-is-a-closure-b2f0d2152b36), [Источник 3](https://learn.javascript.ru/closure)

## 9. Можете ли вы описать основное различие между циклом .forEach и циклом .map()? И в каких случаях каждый из них используется?

https://www.frontendinterviewhandbook.com/ru/javascript-questions/#%D0%BC%D0%BE%D0%B6%D0%B5%D1%82%D0%B5-%D0%BB%D0%B8-%D0%B2%D1%8B-%D0%BE%D0%BF%D0%B8%D1%81%D0%B0%D1%82%D1%8C-%D0%BE%D1%81%D0%BD%D0%BE%D0%B2%D0%BD%D0%BE%D0%B5-%D1%80%D0%B0%D0%B7%D0%BB%D0%B8%D1%87%D0%B8%D0%B5-%D0%BC%D0%B5%D0%B6%D0%B4%D1%83-%D1%86%D0%B8%D0%BA%D0%BB%D0%BE%D0%BC-foreach-%D0%B8-%D1%86%D0%B8%D0%BA%D0%BB%D0%BE%D0%BC-map-%D0%B8-%D0%B2-%D0%BA%D0%B0%D0%BA%D0%B8%D1%85-%D1%81%D0%BB%D1%83%D1%87%D0%B0%D1%8F%D1%85-%D0%BA%D0%B0%D0%B6%D0%B4%D1%8B%D0%B9-%D0%B8%D0%B7-%D0%BD%D0%B8%D1%85-%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D1%83%D0%B5%D1%82%D1%81%D1%8F

## 10. В каких случаях обычно используются анонимные функции?

IIFE и колбэки.

## 11. В чем разница между host-объектами и нативными объектами?

Нативные объекты - это объекты, которые являются частью языка JavaScript, определенного в спецификации ECMAScript: `String`, `Math`, `RegExp`, `Object`, `Function` и т.д.

Хост-объекты предоставляются средой выполнения (браузером или Node), такие как `window`, `XMLHTTPRequest` и т.д.

## 12. В чем разница между: `function Person(){}`, `var person = Person()`, и `var person = new Person()`?

Этот вопрос не совсем понятен. Возможно суть вопроса о конструкторах в JavaScript. Строго говоря, `function Person(){}` - это обычное объявление функции. Принято называть с заглавной буквы функции, которые предназначены для использования в качестве конструкторов.

`var person = Person()` вызывает Person как функцию, а не как конструктор. Вызов как таковой является распространенной ошибкой, если функция предназначена для использования в качестве конструктора. Как правило, конструктор ничего не возвращает, поэтому при вызове конструктора как обычной функции возвращается `undefined`, и это присваивается переменной, предназначенной в качестве экземпляра.

`var person = new Person()` создает экземпляр объекта Person с помощью оператора `new`, который наследуется от `Person.prototype`. Альтернативой может быть использование `Object.create`, например: `Object.create(Person.prototype)`.

## 13. В чем разница между `.call` и `.apply`?

Сходство заключается в том, что и `.call`, и `.apply` используются для вызова функций, а также первый параметр будет использоваться как значение `this` внутри функции. А разница в том, что `.call` в качестве следующих аргументов принимает аргументы, разделенные запятыми, в то время как `.apply` в качестве следующих аргументов принимает массив аргументов.

## 14. Что делает и для чего нужна функция `.bind`?

Метод `bind()` создаёт новую функцию, которая при вызове устанавливает в качестве контекста выполнения `this` предоставленное значение. В метод также передаётся набор аргументов, которые будут установлены перед переданными в привязанную функцию аргументами при её вызове.

Частый пример использования: указание контекста для методов в классовом компоненте React.

## 15. В каких случаях используется `document.write()`?

`document.write()` записывает строку текста в поток документа, открытого при помощи `document.open()`. Когда `document.write()` выполняется после загрузки страницы, он вызывает document.open, который очищает весь документ (<head>и<body> будут удалены!) и заменяет содержимое на заданное значение параметра. Подобный подход считается опасным и не рекомендуется его использовать.

## 16. В чём разница между feature detection (определение возможностей браузера), ferature inference (предположение возможностей) и анализом строки user-agent?

### Feature detection

Определение, поддерживает ли браузер определённый блок кода. Если нет, то будет выполняться другой код, что позволит работать коду в разных браузерах. Из всех перечисленных рекомендуется только этот.
```js
if ('geolocation' in navigator) {
  // Можно использовать navigator.geolocation
} else {
  // Обработка отсутствия возможности
}
```

### Feature inference

Предположение возможностей проверяет на наличие определенных возможностей, как и предыдущий подход, но использует другую функцию, которая предполагает, что определенная возможность уже существует.
```js
if (document.getElementsByTagName) {
  element = document.getElementById(id);
}
```

### Строка User Agent

Способ ещё более ненадёжный, основанный на парсинге строки `User-Agent`. В чём заключается ненадёжность:
- Строку может подменить пользователь.
- Строки трудно распарсить (к примеру, Safari и Google Chrome имеют схожие значения, но разница поддерживаемых функций огромна)
- Нужно анализировать и описывать разницу в версиях браузера.

## 17. Расскажите об AJAX

AJAX (Async Javascript And XML) - набор методов веб-разработки, позволяющих создавать асинхронные веб-приложения и приложения, которые работают с данными сервера без перезагрузок и переходов страниц.

Основные API с AJAX: `XMLHttpRequest`, более актуальное `fetch`.

## 18. Какие преимущества и недостатки в использовании Ajax?

https://www.frontendinterviewhandbook.com/ru/javascript-questions/#%D0%BA%D0%B0%D0%BA%D0%B8%D0%B5-%D0%BF%D1%80%D0%B5%D0%B8%D0%BC%D1%83%D1%89%D0%B5%D1%81%D1%82%D0%B2%D0%B0-%D0%B8-%D0%BD%D0%B5%D0%B4%D0%BE%D1%81%D1%82%D0%B0%D1%82%D0%BA%D0%B8-%D0%B2-%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B8-ajax

## 19. Объясните, как работает JSONP (и почему это не совсем AJAX)

https://www.frontendinterviewhandbook.com/ru/javascript-questions/#%D0%BE%D0%B1%D1%8A%D1%8F%D1%81%D0%BD%D0%B8%D1%82%D0%B5-%D0%BA%D0%B0%D0%BA-%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%B0%D0%B5%D1%82-jsonp-%D0%B8-%D0%BF%D0%BE%D1%87%D0%B5%D0%BC%D1%83-%D1%8D%D1%82%D0%BE-%D0%BD%D0%B5-%D1%81%D0%BE%D0%B2%D1%81%D0%B5%D0%BC-ajax

## 20. Вы когда-нибудь использовали шаблонизацию на JavaScript? Если да, то какие библиотеки вы использовали?

Шаблонизация встречается во всех популярных фреймворках и библиотеках для работы с view-частью. Одни из них - тот же Angular со своими HTML-шаблонами и React с JSX.

## 21. Расскажите, что такое поднятие (hoisting)

https://www.frontendinterviewhandbook.com/ru/javascript-questions/#%D1%80%D0%B0%D1%81%D1%81%D0%BA%D0%B0%D0%B6%D0%B8%D1%82%D0%B5-%D1%87%D1%82%D0%BE-%D1%82%D0%B0%D0%BA%D0%BE%D0%B5-%D0%BF%D0%BE%D0%B4%D0%BD%D1%8F%D1%82%D0%B8%D0%B5-hoisting

## 22. Объясните, что такое всплытие событий (event bubbling)

https://www.frontendinterviewhandbook.com/ru/javascript-questions/#%D0%BE%D0%B1%D1%8A%D1%8F%D1%81%D0%BD%D0%B8%D1%82%D0%B5-%D1%87%D1%82%D0%BE-%D1%82%D0%B0%D0%BA%D0%BE%D0%B5-%D0%B2%D1%81%D0%BF%D0%BB%D1%8B%D1%82%D0%B8%D0%B5-%D1%81%D0%BE%D0%B1%D1%8B%D1%82%D0%B8%D0%B9-event-bubbling

## 23. В чем разница между "атрибутом" (attribute) и "свойством" (property)?

Атрибуты определены в разметке HTML, а свойства определены в DOM. Чтобы проиллюстрировать разницу, представьте, что у нас есть это текстовое поле в HTML: `<input type="text" value="Hello">`.
```js
const input = document.querySelector('input');
console.log(input.getAttribute('value')); // Hello
console.log(input.value); // Hello
```

Но после того, как вы измените значение текстового поля, добавив к нему "World!", будет:
```js
console.log(input.getAttribute('value')); // Hello
console.log(input.value); // Hello World!
```

## 24. Почему не следует расширять нативные JavaScript-объекты?

Расширение встроенного/нативного объекта JavaScript означает добавление свойств/функций к его прототипу. Хотя на первый взгляд это может показаться хорошей идеей, на практике это опасно. Представьте, что ваш код использует несколько библиотек, которые расширяют `Array.prototype`, добавляя один и тот же метод `contains`. В результате код будет работать неверно, если поведение этих двух методов не будет одинаковым.

Единственный случай, при котором можно расширить нативный объект - это при создании полифила, создав собственную реализацию метода, который является частью спецификации JavaScript, но может отсутствовать в устаревших браузерах.

## 25. В чем разница между событием `load` и событием `DOMContentLoaded`?

Событие `DOMContentLoaded` вызывается, когда исходный HTML-документ полностью загружен и обработан, не дожидаясь окончания загрузки таблиц стилей, изображений и скриптов.

Событие `load` происходит только после загрузки DOM и всех зависимых ресурсов.

## 26. В чём разница между `==` и `===`?

https://www.frontendinterviewhandbook.com/ru/javascript-questions/#%D0%B2-%D1%87%D0%B5%D0%BC-%D1%80%D0%B0%D0%B7%D0%BD%D0%B8%D1%86%D0%B0-%D0%BC%D0%B5%D0%B6%D0%B4%D1%83--%D0%B8-

## 27. Объясните same-origin policy в контексте JavaScript

Same-origin policy (принцип одинакового источника) не позволяет JavaScript выполнять запросы за границы домена. Источник определяется как комбинация схемы URI, имени хоста и номера порта. Этот принцип не позволяет вредоносному сценарию на одной странице получить доступ к конфиденциальным данным на другой через объектную модель документа этой страницы.

## 28. Сделайте так, чтобы код `duplicate([1, 2, 3, 4, 5]); // [1,2,3,4,5,1,2,3,4,5]` работал

Через `concat()` или спред-оператор.

## 29. Почему тернарный оператор так называется?

Тернарный = три. Три операнда внутри выражения.

## 30. Что делает строчка `"use strict";`? Какие достоинства и недостатки от ее использования?

### Преимущества:
- Не позволяет случайно создавать глобальные переменные.
- Любое присваивание, которое в обычном режиме завершится неудачей, в строгом выдаст ошибку.
- При попытке удалить неудаляемые свойства, выдаст ошибку.
- Требует, чтоббы имена параметров функций были уникальными.
- `this` в глобальной области = `undefined`.
- Перехватывает распространённые ошибки, выдавая исключения.
- Исключает неочевидные особенности языка.

### Недостатки:
- Нельзя использовать некоторые особенности языка, к которым привыкли некоторые разработчики.
- Нет доступа к `function.caller` и `function.arguments`.
- Объединение скриптов, написанных в строгом режиме, может вызвать проблемы.

## Источники:

- [Frontend Interview Handbook](https://www.frontendinterviewhandbook.com/ru/javascript-questions/)